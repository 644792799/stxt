# The original train of thought:
# At the first, there seems to be 3 solution:
# (1) Only Tree nodes solution, every node can only contains Tree instances as
#	its sub nodes, no other type of attributes except a node value
# (2) Node/Normal solution, just like the file system's dir/file, the setattr
#	do different things depend on the type of attribute(Tree or Non-Tree)
# (3) Since inheritance is a tree, maybe it's possible to make use of that
#
# At last, I choosed (1) because it's the simplest, especially for the node
#	value retrival:
#	root.branch.br1()
#	while (2) is more complicated, for example, its program flow chart
#	<attr existed>
#      |
#      \--Y--<attr is Tree node>
#      |        |
#      |        \--Y--<value is Tree node>
#      |        |        |
#      |        |        \--Y--[replace by a new Tree]
#      |        |        |
#      |        |        \--N--[attr.__node_value = value]       # *1
#      |        |             ?[replace the old Tree by value]
#      |        |
#      |        \--N--<value is Tree node>
#      |                 |
#      |                 \--Y--[replace by a new Tree]           # *2
#      |                 |
#      |                 \--N--[attr = value]
#      |
#      \--N--<new Tree>
#   As you can see, *1, *2 lead to inconsistant, to get a value, you don't know
#	you should use:
#	root.branch.node() or root.branch.node
#	because the conditions of the program varias quickly !
#	(3) seems too complicated, I have no idea about how to make use of that :-)

# class Tree:
# 	_("""A Tree instance can only contains sub Tree instances as its attributes""")
# 	# (1)
# 	# __used_names = None
# 	# __used_names = Tree.__dict__.copy()
# 	# __used_names.update(object.__dict__.copy())
# 	# __used_names = used_names.keys()
# 	# ------------------------------------------------------------------------
# 	__used_names = object.__dict__.copy().keys() + [
# 		'__used_names', '_Tree__node_value', '_Tree__node_items',
# 		'__getattr__', '__setitem__', '__getitem__', '__call__',
# 		'tree', '__traverse__'   ]
# 	def __init__(self, value, **kwargs):
# 		# (2)
# 		# self.__used_names = None
# 		# self.__used_names = Tree.__dict__.copy()
# 		# self.__used_names.update(object.__dict__)
# 		# self.__used_names = self.__used_names.keys()
# 		# (3)
# 		# setattr(self, '__used_names', None)
# 		# setattr(self, '__used_names', Tree.__dict__.copy())
# 		# self.__used_names.update(object.__dict__)
# 		# setattr(self, '__used_names', self.__used_names.keys())
# 		# --------------------------------------------------------------------
# 		# self.__node_value = value
# 		# Both 'self.attribute = value' and 'setattr(self, attr_name, value)'
# 		#	have been influenced by self.__setattr__(),
# 		#	so only self.__dict__ can be used
# 		# A pseudo private attribute should be assigned by this way:
# 		self.__dict__['_Tree__node_value'] = value
# 		# __node_value should always be Non-Tree
# 		self.__dict__['_Tree__node_items'] = {}
# 		for k, v in kwargs.items(): self.__setattr__(k, v)
# 	# def __getattr__(self, attr_name): pass
# 	def __setattr__(self, attr_name, value):
# 		_("""The operation 'root.br1.br2 = value' works on root.br1 rather than root.br1.br2""")
# 		# (4)
# 		# __used_names.Tree.__dict__.copy()
# 		# __used_names.update(object.__dict__.copy())
# 		# __used_names = used_names.keys() + ['__node_value', '__node_items']
# 		# if attr_name in __used_names:
# 		# --------------------------------------------------------------------
# 		if attr_name in self.__used_names:
# 			raise TreeExc(_("Attribute name '%s' is reserved" % attr_name))
#		...
#	......
#
# 	def _one_node_set(self, pathseq, value):
# 	# construct a Tree from a sequence path
#		...
# 		# --- tree#2 ---------------------------------------------------------
# 		# if len(pathseq) > 1:
# 		#	temp = pathseq[0]
# 		#	try:
# 		#		if len(temp.keys()) != 1:
# 		#			raise TreeExc(_("Indexed node name in path sequence need 1 and only 1 element"))
# 		#		next_name = temp.keys()[0]
# 		#		attr_name_check(next_name)
# 		#		key = temp[next_name]
# 		#		next_node = Tree(None)
# 		#		next_node.__setitem__(key, Tree(None))
# 		#		next_node[key]._one_node_set(pathseq[1:], value)
# 		#	except AttributeError:
# 		#		next_name = temp
# 		#		attr_name_check(next_name)
# 		#		next_node = Tree(None)
# 		#		next_node._one_node_set(pathseq[1:], value)
# 		# elif len(pathseq) == 1:
# 		#	temp = pathseq[0]
# 		#	try:
# 		#		if len(temp.keys()) != 1:
# 		#			raise TreeExc(_("Indexed node name in path sequence need 1 and only 1 element"))
# 		#		next_name = temp.keys()[0]
# 		#		attr_name_check(next_name)
# 		#		key = temp[next_name]
# 		#		next_node = Tree(None)
# 		#		next_node.__setitem__(key, Tree(value))
# 		#	except AttributeError:
# 		#		next_name = temp
# 		#		attr_name_check(next_name)
# 		#		next_node = Tree(value)
# 		# --------------------------------------------------------------------
# 		self.__setattr__(next_name, next_node)
#		...
#	......
