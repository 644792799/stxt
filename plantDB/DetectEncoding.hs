module DetectEncoding( Encoding( UTF8, UTF16, UTF16LE, UTF32
                               , UTF32LE
                               , CP950
                               , Unknown)
                     , probeBOM, getChecklines
                     , bLines
                     , probeUTF8, probeCP950, probeString
                     , emptyRun
                     , ProbeRun ( utf8WaitNr, utf8State , isUTF8Error 
                                , utf8ErrorDesc
                                , cp950BChar, cp950Count, cp950Error
                                , resCount  , resEnc
                                )
                     , tryCP950
                     , detectEncoding, detectFileEncoding
                     )
where
import Control.Monad.State.Lazy
import System.IO
import Data.Word
import qualified Data.ByteString as B
import qualified Data.ByteString.Char8 as C

detectEncoding :: B.ByteString -> Encoding
detectEncoding bs =
    case probeBOM bs of 
         Nothing -> resEnc $ execState (probeString bs >> tryCP950)  emptyRun
         Just enc -> enc
    
detectFileEncoding :: FilePath -> IO Encoding
detectFileEncoding f = do
    bs <- readChecklines f 
    return $ detectEncoding bs

readChecklines f = do
    bs <- B.readFile f 
    return $ getChecklines bs


probeString :: B.ByteString -> State ProbeRun () 

-- line separator in windows platform
winsep = B.pack [0x0d, 0x0a] 
bLines :: B.ByteString -> [B.ByteString]
bLines bs = break0D0A bs
    where
        break0D0A :: B.ByteString -> [B.ByteString] 
        break0D0A bs = case B.breakSubstring winsep bs of
             (h, t) | t == B.empty   -> [h] 
                    | otherwise      -> h:(break0D0A $ B.drop 2 t)

probeString bs = do
    let ws = B.unpack bs 
    forM_ ws $ \w -> do 
        probeCP950 w
        probeUTF8 w

tryCP950 = do
    s <- get
    let ProbeRun { isUTF8Error= isutf8error
                 , cp950Error = cp950error 
                 , cp950Count = cp950count
                 , resCount   = rescount
                 , resEnc     = resenc
                 } = s
    -- when (cp950error == 0 && rescount < cp950count) $
    --     put $ s{resCount = cp950count,resEnc = CP950}
    when (rescount < cp950count-cp950error || isutf8error) $
          put $ s{resCount = cp950count,resEnc = CP950}
data Encoding = UTF8    | 
                UTF16   | -- UCS2
                UTF16LE | -- UCS2LE
                UTF32   | -- UCS4
                UTF32LE | -- UCS4LE
                CP950   | -- UCS4LE
                Unknown
                deriving (Eq, Show)

-- It checks first and last several lines of
-- current file, so don't set the value too
-- large. Set to 0 if you want to check every
-- line. (default: 10)
checklines = 30
getChecklines bs = do
    let ls  = bLines bs  
    let len = length ls 
    if len < checklines * 2 || checklines == 0
        then bs
        else C.unlines $ take checklines ls ++ drop (len - checklines) ls

data ProbeRun = ProbeRun { isUTF8Error   :: Bool
                         , utf8State     :: String
                         , utf8WaitNr    :: Int
                         , utf8ErrorDesc :: String
                         , cp950BChar    :: Word8
                         , cp950Count    :: Int
                         , cp950Error    :: Int
                         , resCount      :: Int
                         , resEnc        :: Encoding
                         } deriving (Eq, Show)

emptyRun = ProbeRun { isUTF8Error   = False
                    , utf8State     = "start"
                    , utf8WaitNr    = 0
                    , utf8ErrorDesc = ""
                    , cp950BChar    = 0x0
                    , cp950Count    = 0
                    , cp950Error    = 0
                    , resCount      = 0
                    , resEnc        = UTF8
                    }
-- "still not full support here
-- "U-00000000 - U-0000007F:  0xxxxxxx
-- "U-00000080 - U-000007FF:  110xxxxx 10xxxxxx
-- "U-00000800 - U-0000FFFF:  1110xxxx 10xxxxxx 10xxxxxx
-- "U-00010000 - U-001FFFFF:  11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
-- "U-00200000 - U-03FFFFFF:  111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
-- "U-04000000 - U-7FFFFFFF:  1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
probeUTF8 :: Word8 -> State ProbeRun ()
probeUTF8 c = do
    s <- get
    let ProbeRun { isUTF8Error= isutf8error
                 , utf8State  = utf8state 
                 , utf8WaitNr = utf8waitnr 
                 } = s
    
    unless isutf8error $ do -- if error occurs, do nothing.
        if (utf8state == "start") 
          then case c of 
               _ | c <=      0x7f          -> return () --still start state
                 | c `elem` [0xc2..0xdf]   -> put $ s{utf8State = "wait", 
                                                      utf8WaitNr=1}
                 | c `elem` [0xe0..0xef]   -> put $ s{utf8State = "wait", 
                                                      utf8WaitNr=2}
                 | c `elem` [0xf0..0xf7]   -> put $ s{utf8State = "wait", 
                                                      utf8WaitNr=3}
                 | c `elem` [0xf8..0xfb]   -> put $ s{utf8State = "wait", 
                                                      utf8WaitNr=4}
                 | c `elem` [0xfc..0xfd]   -> put $ s{utf8State = "wait", 
                                                      utf8WaitNr=5}
                 | otherwise               -> put $ s{isUTF8Error=True
                                                     ,utf8ErrorDesc=(show c ++ " start error")
                                                     }
 
         else when (utf8state == "wait") $ case c of --  utf8state = "wait"
               _ | c `elem` [0x80..0xbf]   -> do
                     let newWaitNr = utf8waitnr - 1
                     put $ s{utf8WaitNr=newWaitNr}
                     when (newWaitNr==0) $ put $ s{ utf8State="start"
                                                  , utf8WaitNr=newWaitNr
                                                  }
                 | otherwise            -> put $ s{ isUTF8Error=True
                                                  , utf8WaitNr=0
                                                  , utf8State="start"
                                                  , utf8ErrorDesc=show c ++ " wait error"
                                                  }

probeCP950 :: Word8 -> State ProbeRun ()
probeCP950 c = do 
    s <- get
    let bc = cp950BChar s
    if bc <= 0x80 
       then when (c > 0x80) $ do 
            put $ s{cp950BChar=c}
       else if c < 0x40
               then put $ s{ cp950BChar = 0x0
                           , cp950Error = cp950Error s + 1
                           }
               else do
                    let wc =(cp950BChar s, c)
                    when (wc `elem` cp950TopChars) $ 
                        put $ s{ cp950BChar = 0x0
                               , cp950Count = cp950Count s + 1
                               }

-- Vim can probe the file encoding by BOM correctly.
-- This function is used to prevent probing other
-- encodings by mistake.
probeBOM :: B.ByteString -> Maybe Encoding
probeBOM bs  
    | B.take 3 bs == B.pack[0xef, 0xbb, 0xbf]       = Just UTF8
    | B.take 2 bs == B.pack[0xfe, 0xff]             = Just UTF16
    | B.take 2 bs == B.pack[0xff, 0xfe]             = Just UTF16LE
    | B.take 4 bs == B.pack[0x00, 0x00, 0xfe, 0xff] = Just UTF32
    | B.take 4 bs == B.pack[0xff, 0xfe, 0x00, 0x00] = Just UTF32LE
    | otherwise                                     = Nothing


cp950TopChars=[(0xaa,0xba),(0xa4,0x40),(0xb0,0xea),(0xa6,0x62),(0xa4,0x48),(0xa4,0x46),(0xa6,0xb3),(0xa4,0xa4), (0xac,0x4f),(0xa6,0x7e),(0xa9,0x4d),(0xa4,0x6a),(0xb7,0x7e),(0xa4,0xa3),(0xac,0xb0),(0xb5,0x6f), (0xb7,0x7c),(0xa4,0x75),(0xb8,0x67),(0xa4,0x57),(0xa6,0x61),(0xa5,0xab),(0xad,0x6e),(0xad,0xd3), (0xb2,0xa3),(0xb3,0x6f),(0xa5,0x58),(0xa6,0xe6),(0xa7,0x40),(0xa5,0xcd),(0xae,0x61),(0xa5,0x48), (0xa6,0xa8),(0xa8,0xec),(0xa4,0xe9),(0xa5,0xc1),(0xa8,0xd3),(0xa7,0xda),(0xb3,0xa1),(0xb9,0xef), (0xb6,0x69),(0xa6,0x68),(0xa5,0xfe),(0xab,0xd8),(0xa5,0x4c),(0xa4,0xbd),(0xb6,0x7d),(0xad,0xcc), (0xb3,0xf5),(0xae,0x69),(0xae,0xc9),(0xb2,0x7a),(0xb7,0x73),(0xa4,0xe8),(0xa5,0x44),(0xa5,0xf8), (0xb8,0xea),(0xb9,0xea),(0xbe,0xc7),(0xb3,0xf8),(0xa8,0xee),(0xac,0x46),(0xc0,0xd9),(0xa5,0xce), (0xa6,0x50),(0xa4,0x5f),(0xaa,0x6b),(0xb0,0xaa),(0xaa,0xf8),(0xb2,0x7b),(0xa5,0xbb),(0xa4,0xeb), (0xa9,0x77),(0xa4,0xc6),(0xa5,0x5b),(0xb0,0xca),(0xa6,0x58),(0xab,0x7e),(0xad,0xab),(0xc3,0xf6), (0xbe,0xf7),(0xa4,0xc0),(0xa4,0x4f),(0xa6,0xdb),(0xa5,0x7e),(0xaa,0xcc),(0xb0,0xcf),(0xaf,0xe0), (0xb3,0x5d),(0xab,0xe1),(0xb4,0x4e),(0xb5,0xa5),(0xc5,0xe9),(0xa4,0x55),(0xb8,0x55),(0xa4,0xb8), (0xaa,0xc0),(0xb9,0x4c),(0xab,0x65),(0xad,0xb1),(0xb9,0x41),(0xa4,0x5d),(0xb1,0x6f),(0xbb,0x50), (0xbb,0xa1),(0xa4,0xa7),(0xad,0xfb),(0xa6,0xd3),(0xb0,0xc8),(0xa7,0x51),(0xb9,0x71),(0xa4,0xe5), (0xa8,0xc6),(0xa5,0x69),(0xba,0xd8),(0xc1,0x60),(0xa7,0xef),(0xa4,0x54),(0xa6,0x55),(0xa6,0x6e), (0xaa,0xf7),(0xb2,0xc4),(0xa5,0x71),(0xa8,0xe4),(0xb1,0x71),(0xa5,0xad),(0xa5,0x4e),(0xb7,0xed), (0xa4,0xd1),(0xa4,0xf4),(0xac,0xd9),(0xb4,0xa3),(0xb0,0xd3),(0xa4,0x51),(0xba,0xde),(0xa4,0xba), (0xa4,0x70),(0xa7,0xde),(0xa6,0xec),(0xa5,0xd8),(0xb0,0x5f),(0xae,0xfc),(0xa9,0xd2),(0xa5,0xdf), (0xa4,0x77),(0xb3,0x71),(0xa4,0x4a),(0xb6,0x71),(0xa4,0x6c),(0xb0,0xdd),(0xab,0xd7),(0xa5,0x5f), (0xab,0x4f),(0xa4,0xdf),(0xc1,0xd9),(0xac,0xec),(0xa9,0x65),(0xb3,0xa3),(0xb3,0x4e),(0xa8,0xcf), (0xa9,0xfa),(0xb5,0xdb),(0xa6,0xb8),(0xb1,0x4e),(0xbc,0x57),(0xb0,0xf2),(0xa6,0x57),(0xa6,0x56), (0xaa,0xf9),(0xc0,0xb3),(0xb8,0xcc),(0xac,0xfc),(0xa5,0xd1),(0xb3,0x57),(0xa4,0xb5),(0xc3,0x44), (0xb0,0x4f),(0xc2,0x49),(0xad,0x70),(0xa5,0x68),(0xb1,0x6a),(0xa8,0xe2),(0xa8,0xc7),(0xaa,0xed), (0xa8,0x74),(0xbf,0xec),(0xb1,0xd0),(0xa5,0xbf),(0xb1,0xf8),(0xb3,0xcc),(0xb9,0x46),(0xaf,0x53), (0xad,0xb2),(0xa6,0xac),(0xa4,0x47),(0xb4,0xc1),(0xa8,0xc3),(0xb5,0x7b),(0xbc,0x74),(0xa6,0x70), (0xb9,0x44),(0xbb,0xda),(0xa4,0xce),(0xa6,0xe8),(0xa4,0x66),(0xa8,0xca),(0xb5,0xd8),(0xa5,0xf4), (0xbd,0xd5),(0xa9,0xca),(0xbe,0xc9),(0xb2,0xd5),(0xaa,0x46),(0xb8,0xf4),(0xac,0xa1),(0xbc,0x73), (0xb7,0x4e),(0xa4,0xf1),(0xa7,0xeb),(0xa8,0x4d),(0xa5,0xe6),(0xb2,0xce),(0xc4,0xd2),(0xab,0x6e), (0xa6,0x77),(0xa6,0xb9),(0xbb,0xe2),(0xb5,0xb2),(0xc0,0xe7),(0xb6,0xb5),(0xb1,0xa1),(0xb8,0xd1), (0xc4,0xb3),(0xb8,0x71),(0xa4,0x73),(0xa5,0xfd),(0xa8,0xae),(0xb5,0x4d),(0xbb,0xf9),(0xa9,0xf1), (0xa5,0x40),(0xb6,0xa1),(0xa6,0x5d),(0xa6,0x40),(0xb0,0x7c),(0xa8,0x42),(0xaa,0xab),(0xac,0xc9), (0xb6,0xb0),(0xa7,0xe2),(0xab,0xf9),(0xb5,0x4c),(0xa6,0xfd),(0xab,0xb0),(0xac,0xdb),(0xae,0xd1), (0xa7,0xf8),(0xa8,0x44),(0xaa,0x76),(0xa8,0xfa),(0xad,0xec),(0xb3,0x42),(0xa9,0xb2),(0xac,0xe3), (0xbd,0xe8),(0xab,0x48),(0xa5,0x7c),(0xb9,0x42),(0xbf,0xa4),(0xad,0x78),(0xa5,0xf3),(0xa8,0x7c), (0xa7,0xbd),(0xb7,0x46),(0xb6,0xa4),(0xb9,0xce),(0xa4,0x53),(0xb3,0x79),(0xa7,0xce),(0xaf,0xc5), (0xbc,0xd0),(0xc1,0x70),(0xb1,0x4d),(0xa4,0xd6),(0xb6,0x4f),(0xae,0xc4),(0xbe,0xda),(0xa4,0xe2), (0xac,0x49),(0xc5,0x76),(0xa6,0xbf),(0xaa,0xf1),(0xb2,0x60),(0xa7,0xf3),(0xbb,0x7b),(0xaa,0x47), (0xae,0xe6),(0xb4,0x58),(0xac,0xdd),(0xa8,0x53),(0xc2,0xbe),(0xaa,0x41),(0xa5,0x78),(0xa6,0xa1), (0xaf,0x71),(0xb7,0x51),(0xbc,0xc6),(0xb3,0xe6),(0xbc,0xcb),(0xa5,0x75),(0xb3,0x51),(0xbb,0xf5), (0xa6,0xd1),(0xa8,0xfc),(0xc0,0x75),(0xb1,0x60),(0xbe,0x50),(0xa7,0xd3),(0xbe,0xd4),(0xac,0x79), (0xab,0xdc),(0xb1,0xb5),(0xb6,0x6d),(0xc0,0x59),(0xb5,0xb9),(0xa6,0xdc),(0xc3,0xf8),(0xc6,0x5b), (0xab,0xfc),(0xb3,0xd0),(0xb5,0xfd),(0xc2,0xb4),(0xbd,0xd7),(0xa7,0x4f),(0xa4,0xad),(0xa8,0xf3), (0xc5,0xdc),(0xad,0xb7),(0xa7,0xe5),(0xa8,0xa3),(0xa8,0x73),(0xa4,0xe4),(0xa8,0xba),(0xac,0x64), (0xb1,0x69),(0xba,0xeb),(0xa8,0x43),(0xaa,0x4c),(0xc2,0xe0),(0xb9,0xba),(0xb7,0xc7),(0xb0,0xb5), (0xbb,0xdd),(0xb6,0xc7),(0xaa,0xa7),(0xb5,0x7c),(0xba,0x63),(0xa8,0xe3),(0xa6,0xca),(0xa9,0xce), (0xa4,0x7e),(0xbf,0x6e),(0xb6,0xd5),(0xc1,0x7c),(0xa5,0xb2),(0xab,0xac),(0xa9,0xf6),(0xb5,0xf8), (0xa7,0xd6),(0xa7,0xf5),(0xb0,0xd1),(0xa6,0x5e),(0xa4,0xde),(0xc2,0xed),(0xad,0xba),(0xb1,0xc0), (0xab,0xe4),(0xa7,0xb9),(0xae,0xf8),(0xad,0xc8),(0xb8,0xd3),(0xa8,0xab),(0xb8,0xcb),(0xb2,0xb3), (0xb3,0x64),(0xb3,0xc6),(0xa6,0x7b),(0xa8,0xd1),(0xa5,0x5d),(0xb0,0xc6),(0xb7,0xa5),(0xbe,0xe3), (0xbd,0x54),(0xaa,0xbe),(0xb6,0x54),(0xa4,0x76),(0xc0,0xf4),(0xb8,0xdc),(0xa4,0xcf),(0xa8,0xad), (0xbf,0xef),(0xa8,0xc8),(0xbb,0xf2),(0xb1,0x61),(0xb1,0xc4),(0xa4,0xfd),(0xb5,0xa6),(0xaf,0x75), (0xa4,0x6b),(0xbd,0xcd),(0xc4,0x59),(0xb4,0xb5),(0xaa,0x70),(0xa6,0xe2),(0xa5,0xb4),(0xbc,0x77), (0xa7,0x69),(0xb6,0xc8),(0xa5,0xa6),(0xae,0xf0),(0xae,0xc6),(0xaf,0xab),(0xb2,0x76),(0xc3,0xd1), (0xb3,0xd2),(0xb9,0xd2),(0xb7,0xbd),(0xab,0x43),(0xc5,0x40),(0xa6,0x43),(0xbf,0xb3),(0xb3,0x5c), (0xa4,0xe1),(0xb0,0xa8),(0xb4,0xe4),(0xab,0x68),(0xb8,0x60),(0xb4,0xda),(0xa9,0xd4),(0xaa,0xbd), (0xae,0xd7),(0xaa,0xd1),(0xa5,0xfa),(0xb8,0xfb),(0xaa,0x65),(0xaa,0xe1),(0xae,0xda),(0xa5,0xac), (0xbd,0x75),(0xa4,0x67),(0xa7,0x4a),(0xa6,0x41),(0xb8,0x73),(0xc2,0xe5),(0xb2,0x4d),(0xb3,0x74), (0xab,0xdf),(0xa6,0x6f),(0xb1,0xda),(0xbe,0xfa),(0xab,0x44),(0xb7,0x50),(0xa6,0xfb),(0xc4,0xf2), (0xae,0x76),(0xa6,0xf3),(0xbc,0x76),(0xa5,0x5c),(0xad,0x74),(0xc5,0xe7),(0xb1,0xe6),(0xb0,0x5d), (0xc3,0xfe),(0xb3,0x66),(0xac,0xf9),(0xc3,0xc0),(0xb0,0xe2),(0xb3,0x73),(0xac,0xf6),(0xab,0xf6), (0xb0,0x54),(0xa5,0x76),(0xa5,0xdc),(0xb6,0x48),(0xbe,0x69),(0xc0,0xf2),(0xa5,0xdb),(0xad,0xb9), (0xa7,0xec),(0xb4,0x49),(0xbc,0xd2),(0xa9,0x6c),(0xa6,0xed),(0xc1,0xc9),(0xab,0xc8),(0xb6,0x56), (0xbb,0x44),(0xa5,0xa1),(0xae,0x75),(0xb0,0xed)]

