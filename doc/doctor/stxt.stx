自然文字排版系統
----------------
0990405

文件排版系統，在目前分化成以下兩種取向：

第一種取向為主流且大眾化之所見即所得文件編輯器，
此種編輯器為視覺導向，操作容易，
且能看到與列印輸出相差無幾的文件，
但其缺點為文件結構與視覺排版無法分離，
使得同一種文件想產生多種輸出有很大的困難。

此外上述文件其儲存格式多為二進位編碼，
文件少許的修正改變，會使得整個儲存編碼可能完全不一樣，
因此此種文件無法用版本控管系統作分析。

第二種取向為 XML 文件，
其能表達純文件結構，並獨立於視覺排版之外，
且文件可用可讀性高的純文字碼編碼，而非二進位編碼，
有利於文件交換。

但階層太深的標籤控制碼，
讓人們已無法從編碼直接看出文件結構，
且標籤控制碼可能佔到文件碼近 1/3 的可能性。

研究目的   
--------
本研究企圖建立一個自然文字排版系統，
其文件為純文字文件，
但利用直覺排版來表示文件結構，
非使用主流的標籤語言，來表示文件結構，
可取二者所長，避其所短。

系統能達成 XML 大部份的功能，
但其書寫結構是簡單且直覺的，
直覺的知識表示語言是最重要的目標。

本文認為自然語言是最好的知識表示語言，
這個剖析器應該介於程式語言與自然語言間，
除了滿足需求，源碼可讀性是最重要的，
而非如 XML 太過傾向機器可讀性及剖析效能。

研究設計
--------
0990405

以自然純文字視覺排版作為文法
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0990405

本研究為了克服 XML 文件階層太深的標籤控制碼，
讓人們已無法從編碼直接看出文件結構，
不使用標籤作為文件結構的唯一表示法，
而是利用直覺排版之結構來表示文件結構。

純文字視覺排版具有以下幾種結構：
1.縮排
2.欄
3.行
4.連續字元
5.行起始字元

XML 已忽略欄、行、首排前置字元等結構，
僅有純標籤結構。

雖然其結構較 XML 為特殊，
且不易設計剖析器，但其較 XML 自然，
具由於結構比 XML 之標籤結構多元，
故一定能表示 XML 所能表示之結構

多次剖析取向
~~~~~~~~~~~~
0990310

一般剖析器都為__單次剖析__或__二次剖析__，
但若將字彙分析器(lexer)算入，
則所有剖析器至少都為二次剖析。

code[doc_struc].文件結構
  書
  | \
  章 章
 / | \
段 段 段
  /| \
詞 詞 詞
::

多次剖析比較接近人類去剖析自然語言的技巧，
如[[doc_struc]]所示，通常文件結構為階層式組織，
人類閱讀文件時則是依此階層組織依上而下的次序閱讀。

先剖析文件所表示的上層結構來理解及記憶此結構，
再選擇此結構的一個子元素，通常選擇規則為最先看到的元素，
再剖析此元素所表示的第二層結構。

假設閱讀一本「資料庫理論」的書，
先由書名「資料庫理論」暸解此書主要關注資料庫的基本理論。

再看文件下一層結構「章節」，
設此章節名稱為「SQL」，
人們會暸解此章節主要的關注資料庫理論中關於 SQL 方面的理論。

code.二維結構
  y(剖析層次)
  |\
  | \
  |  \
  |   \ 
  |    \
--+----------x(剖析複雜度)
::

若將剖析層次作為 y 軸，而 x 作為剖析複雜度，
則兩者應該類似於反比關係。

每迴剖析所產出之結果，均能作為下迴剖析的輸入，
此結果之每個符號都能代表上一迴的剖析狀態。

剖析程序
~~~~~~~~
0990423

code.剖析程序

Source -(text)-> Lexer -(tokens)-> Parser -(tree)->  
Tabler -(tree)-> Inliner -(tree)-> Formater -(target code)

::

當剖析產出文件樹時，因為之後的剖析輸入文件樹，產出文件樹，
所以可以任意加入中間剖析，
最後一道為目的碼產生器，
但樹必須記載源碼之資訊，以便日後除錯。

Lexer 之功能
~~~~~~~~~~~~
0990430

Lexer 須滿足以下功能：
  1.字元碼轉成字元中間表示碼(如 python 之 unicode)
  2.線性模式之剖析，一般以正規表示式作模式之描述
  3.產出表示模式之 token
  4.儲存源碼之位置訊息，以利事後除錯
  5.處理巨大檔之讀取

以文件樹組織剖析結果
~~~~~~~~~~~~~~~~~~~~
0990311

因剖析歷程具階層關係，
故樹狀結構最適合用來組織此種剖析結構。

當剖析完文件第一層結構時，把剖析結果加入根，
並進而選出第一層結構某一元素作進一步剖析時，
可將剖析結果作為子元素加入剖析時的元素。

整個文件剖析完成後，便形成一個文件樹。

縮排
~~~~
0990405

行縮排很適合來表示階層架構。

code.多層次條列(Multiple Level List)
* 第一層條列一

  第一層段落  
  * 第二層條列一
    * 第三層條列一
::

如[[多層次條列]]所示之 StructedText 源碼，
其以前置雙空白表示階層之文件關係。 

遞迴剖析
~~~~~~~~
0990311

例如多層次條列，便可用遞迴剖析，
達到不限定層次深度的條列文法。

code.多層次條列(Multiple Level List)
* 第一層條列一

  第一層段落  
  * 第二層條列一
    * 第三層條列一
::

如[多層次條列]所示之 StructedText 源碼，
其以前置雙空白表示階層關係，
如何達到不限定層次的剖析。

code.條列文法
list         | listitem
             : list listitem
listitem     | listhead
             : listitem subdoc
listhead     : LI
subdoc       : indent_block
indent_block : INDENT
             | indent_block INDENT
LI           : ^\*\s(.*)
INDENT       : ^\s\s(.+)$
::

Python 語言具有一個類似結構，
也是用縮排來表示階層，但並非利用遞迴剖析，
所以每一行都具有一個縮排階層(Indention level)數字來表示縮排，

除錯資訊(Debug Information)
~~~~~~~~~~~~~~~~~~~~~~~~~~~
0990417

除錯資訊應能對使用者指出錯誤發生之源碼位置，
至少包含原始檔名及字元數，
由於原始檔一般都以行來組織，
行數已變成必要資訊。

STXT 其中間表示為文件樹，
為了除錯使用，節點應有源碼位置資訊。

前端介面(frontend)
~~~~~~~~~~~~~~~~~~
0990430

前端介面是命令式介面之主控台。
