測試驅動開發(TDD)
-----------------
0990322

為什麼要先寫測試？
~~~~~~~~~~~~~~~~~~
這篇說明寫 unit test的好處，以及為何先寫 unit test 再實作，比實作完再補 unit test 更好。這裡先列出摘要：

測試碼可以簡省手動測試的時間，
但有錯時無法告訴我們錯誤的源頭在那。
unit test 可以告訴我們錯誤的源頭在那，
可是 unit test 有時間成本和維護成本。
寫過多 unit test 反而有害。
TDD 藉由先寫測試避開 unit test 的成本問題，並帶來其它好處。

為什麼要寫測試碼？
吃燒餅那有不掉芝麻，寫程式自然要驗證程式是否正確。
想像平時我們如何驗證程式？大概就是寫一寫，執行看看，
看看輸出符不符合預期，換些不同輸入，
再看看結果，有錯再改，改完再重跑．．．。
測試碼可以協助我們自動化驗證，省時省力。

也許有人會懷疑寫測試碼不划算，功能常改變，到時測試碼又要重改。
這個問題視情況有不同種解法，比方用較「便宜」的方式寫測試，
像是準備好輸出入檔，用 shell script 執行，
配合 diff 看輸出是否一致。
或是用 scripting language (如 Python) 寫簡單測試。
而更根本的解法，個人認為是配合 TDD，待後面說明。

手動執行測試，執行個三十年，每次花的時間還是一樣，
也許還會因為手酸變慢。但寫測試碼則相反，我們會愈寫愈快，愈寫功能愈好。

為什麼要寫 unit test (單元測試)？
首先介紹不同級別的測試碼，由小到大依序為：

unit test：測試對象為單一函式。
integration test：測試對象為數個單元函式的複合體。我沒特別區分這個和 unit test [*1]，以下兩者一起用 unit test 表示。
system test：測試整個系統。
acceptance test：客戶驗收用的測試。
將使用情節或使用需求轉成 acceptance test，
藉以確認產品滿足客戶要求，方便起見，以下以 system test 統稱。

備註 *1：在談論 mock 時，unit test 和 integration test 的差異較明顯，本文不談這個議題，總得讓大家有意願寫測試，再來談如何寫測試才有意義，你說對吧。

以測試的觀點來看，system test 的 test case 夠多，system test 應該能涵蓋到大範圍的產品碼，如此一來也達成我們一開始提的「驗證」目的。從實務觀點來看，寫愈多測試碼，負擔愈多，規格變動時要改的東西也多。更何況 unit test 著眼點更細，變更實作方式也有可能得改 unit test。如此一來，為什麼要寫 unit test？

首先，unit test 著眼點比 system test 小，也意味著當測試結果不對時，unit test 可以指出更明確的問題點，而 system test 只能粗略地和我們說輸出不對，接著我們得比對正確和錯誤的輸出，開始推測 bug 在那，並用 debugger 設中斷，或在程式內輸出訊息一步步找出問題源頭。相信大家都能明白除錯的痛苦。而 unit test 可以協助我們釐清那些程式是對的，那些是錯的，將問題範圍縮小。若 unit test 寫得好，幾乎用不到 debugger 和輸出訊息，光看那個 unit test 錯誤，就知道 bug 在那。

除了幫自己省時間外，unit test 也可幫助別人維護和理解程式。維護的人不如自己熟悉，難免不小心改爛程式，unit test 可以減少這類問題，也讓原作者安心給其他人修改。新手要閱讀程式時，unit test 可看成是各函式的使用範例，相信大家都同意讀例子比讀全部程式碼來得容易吧。好的範例有時比註解還有用。

為什麼要先寫測試？
好吧，若讀者大人耐著性子看到這裡，想必已對測試碼已有些心動，也認為寫 unit test 有那麼幾分道理，那先寫測試和後寫測試有什麼差別？若後來寫的程式不管用，需求變更，先寫測試不是搬磚砸自己的腳，自找麻煩嗎？事實上正好相反。

我們得先問自己，為什麼程式會不管用？為什麼需求會變更？去除客戶或主管找麻煩的因素外，一部份原因為思慮不週，寫的功能不夠貼近目標。如同產品一般，沒試用過我們不會明白產品的缺點在那，函式也是一樣。先寫測試碼就是先想像要如何使用即將要寫的函式，在寫測試碼的同時，我們同時也在設計函式。有時會發現難以測試，而想出更簡潔的介面。當我們能輕鬆寫出測試碼時，也意味著目標函式易於使用，之後才方便重用。

再者，先寫測試，相當於先列需求，規範中的輸入為何？預期輸出為何？可能有什麼例外情況？於是，我們接著寫出的程式，一定是有用的。我們不會忽然想說「要不要加個 foo()，之後大概會用到吧。」先寫測試，確保之後寫出的每一行產品碼都是有意義的。同時，我們寫的測試碼也是有意義的，若事後再補測試，不明白加入一個 unit test 有何幫助，有時會多寫不必要的 unit test，如同前面提過，測試碼不是萬靈丹，它也同時是負擔，需求變更時，有時也得一併改測試碼。再者，先寫測試表示有先考慮程式的可測性 (testability)，使得程式容易測試，通常會將程式拆得很細，待寫產品碼時容易將寫好的小函式組成目標功能；完成產品碼後再來補測試則困難許多，由於寫產品碼時沒有考慮到寫測試的需求，結果是影響測試碼的品質，甚至變成過於難寫而不補上測試。

除幫助設計、減少寫冗碼的機會外，先寫測試還方便我們之後進行重構。沒有測試碼的重構是很危險的，而沒重構的程式碼也是很危險的 [*2]，就像在底層不穩的地基上不斷加蓋偷工減料的高樓一般。先寫測試的好處還有一點，早寫早享受，先寫測試，就能先自動化驗證，省去所有手動驗證。

備註 *2：為什麼要重構？這是一個值得獨立討論的議題，主因為減少隱藏的 bug 和強化程式碼的可讀性，並更容易重用，以及增加新功能。詳見 Martin Fowler 寫的 《重構：改善既有程式的設計》

綜合以上所言，先寫測試花費的時間，可以攤算在設計時間，以及減少寫無用程式、減少手動驗證、縮短除錯的時間，所以先寫測試不見得會增加額外時間，我們只是把投入不划算事上的時間，先拿來寫測試。

特別加贈：何時該寫新的測試碼？
雖然寫測試好處多多，也別卯起勁來狂寫，最後卻覺得投資沒回本，浪費過多時間寫測試。遵照 TDD 的原則，先依規格寫測試，別浪費時間寫也許有用的測試。

那麼，何時才是跳出 TDD 迴圈，另外加寫測試的時機呢？依我個人經驗，我發現以下三個情況，都是寫新測試碼的好時機：

在程式裡輸出訊息找錯誤：與其花時間寫 print、看輸出訊息、再回頭砍掉 print，不如寫個 unit test，之後能持續受惠。
執行 debugger：同上，你還是得花時間設中斷，一步步看訊息，不如寫個 unit test，之後能持續受惠。
不知錯誤在那，該如何進行下一步：這表示一次貪心實作太多功能，把目標縮小，一步步補 unit test 吧。
另外，在解 bug 時，先寫個 unit test 重製問題，再開始除錯。如此一來可確保自己明白成因，之後同樣的 bug 也不會再出現。

超級加贈：若 TDD 這麼好用，為啥它不遍及？
施主，這個問題得問你自己啊，快來加入推廣 TDD 的行列吧！

說正經的，雖然上面將寫 unit test 和 TDD 說得如此美好，寫 unit test 不是簡單的事。若寫得不好，就會有「改變實作，也得改變測試」的副作用，或是測試執行過久，不方便反覆執行，或是寫出無用的測試。如同學習 design pattern 一般，unit test 也有 design pattern，對沒接觸過寫測試碼的人來說，相當於要花「兩倍」時間學習。加上前面提到大家可能有的誤解，使得 TDD 難以落實。

另一個可能是，若你的組織同時有兩批人馬對同一產品進行開發和除錯，程式碼分成兩個 branch：一個加入新功能，一個除錯。重構會造成程式碼難以合併，決策者因而選擇不頻繁重構。並且，這類組織可能有龐大的人力另外進行測試 (可看成是 system / acceptance test)，而誤以為不需要 unit test。

然而，長遠來看，第一個理由顯然是偷懶，只是把現在的問題延後到日後再解決。趁早把除錯的時間省下來，投資到 TDD 這積優股吧。第二個情況可能是公司考量，專業分工使得公司容易找人和培訓，我沒在這類公司工作的經驗，不知能如何對應。

詳細的 TDD 風險，可參照 What is the downside to Test Driven Development?。結論是團隊要有熱情學一堆新技術，或是有個經驗老道的開發者帶才適合用 TDD。不過，我個人的觀點是，現實世界的選擇不是非一即零，不是所有程式都能 TDD，若成本過高用 TDD 不划算，那就暫時別花時間學相關技巧，挑軟柿子吃。至少，有用 TDD 的部份就能享受到 TDD 帶來的好處。別因為一些可能想見的問題，而全盤否定使用 TDD。

我對 TDD 充滿熱血，請問如何入門？
好吧，這個標題是我寫來自 high 的。若有興趣的話，可以參考 The Bowling Game Kata 的投影片，由設計保齡球計分程式的小例子，一步步展示 TDD 進行的過程，相信跟著例子走一次必能有所啟發，親身體驗 TDD 如何帶來新設計。若能自己先寫一遍，再來看投影片，感受會更深。或是參閱我之前寫的介紹文：《TDD 推廣：背景知識和簡介》以及《最近用 Python + TDD 心得（與 Java 做對照）》。

TDD 的概念很簡單，看過例子後應該能馬上使用，但無法立即精通 TDD 。
它是一個習慣，而培養習慣需要時間累積。
養成習慣後，接著需要提昇測試和重構的技巧，
才能逐步提昇效果並降低使用 TDD 的成本。
如同過去學 Design Pattern 或其它寫程式的技巧一般，
需要讀書和時間練習。我
在前幾次使用 TDD 時有犯一些錯，使得效果打折，
有感受到一些好處，但也對一些壞處感到疑惑。直到寫了
五、六個小專案後，才釐清一些疑慮，確信 TDD 是很划算的取捨，
從而決定持續使用 TDD。最近用它寫超過一萬行程式，更加感受到它的威力。


之前我曾獨自一人用 TDD (Test Driven Development，中譯為測試驅動開發)
的方式，分別用 Python 和 C++ 各寫了一千多行的小程式，
感覺滿好的。最近剛好有機會寫一個新專案，
就趁這機會開始第三次的 TDD 練習。和前兩次不同的是，
這次要和一位組員合作，以 Java 開發。
看來正是測試 TDD 威能的最好時機。

由於我的組員缺乏寫測試程式的經驗，
剛好可以用來評估是否能在組內推廣 TDD。
雖然我之前有過兩次 TDD 開發經驗，但也只是自己邊看文件邊摸索，
經驗仍嫌不足。這次進行 TDD 讓我多花了不少心力查相關資料。
但是為了擺脫軟體開發後期的泥沼，現在先下點苦工是值得的。
這裡記錄一下過程中的心得。

TDD 簡介
TDD 是個知難行易的道理。知難，是因為我們很難相信它，
到不是因為 TDD 概念很複雜，只要三句話就可以交待完 TDD：

先寫簡單的單元測試，
並執行它。
用最簡單的方法實作需要的功能，
讓程式能通過測試。
重構程式，並確保重構後的程式仍能通過測試。
實務上，這三條規則蘊含了經年累月的經驗法則。
若沒親身體驗過，再怎麼解釋它們帶來的好處，也很難令人信服。
這三條規則是環環相扣的，由於有先寫測試，
才能安心地重構；由於有重構，才能方便地擴充功能；由於專注於最簡單的實作，
省掉 over-design 的時間，才能用更快的速度完成該作的事，
並有多餘時間寫測試程式和重構。藉由測試程式，
程式設計師可以提高對程式碼的信心；
透過重構，程式碼易於修改和重用。注意這裡強調「最簡單」的實作，
這正是 TDD 精神所在，簡單的實作易於進行，複雜的考量如程式碼是否能重用、
是否易於擴充，都留待第三步再做。專心正是將事做得又快又好的祕訣。

天下沒有白吃的午餐，要做到如上所述的理想世界，
必須學許多寫測試程式的技巧。
如同平常寫程式有輔助工具、函式庫、設計模式等，測試程式亦有對應的東西要學。
舉例來說，產品用的程式需要重構，測試用的程式也需要重構。
關鍵在於「treating their tests like first-class citizens. 」。
反之若將測試程式視為可有可無的附帶程式，
只會陷入惡性循環，改變產品用程式的細節得改變測試用程式，
反而變成得改兩倍的程式，以及在兩份程式中除錯。
結果變得更糟，並誤認為測試程式是累贅。
我剛用 TDD 時就因為沒把測試程式寫成許多小巧的函式，
或是沒有寫成正確的檢查方式，造成產品用的程式是對的，
卻常在測試程式裡除錯，造成無謂的損耗。


TDD 的影響
只要用 TDD 重寫以前寫過的小專案，就會發現最後的產出，
和原本寫的程式不同。舉例來說，會發現少了很多 setter function，
因為大多情況只要用 constructor 放值即可。
更進一步，會發現少寫了許多功能，而這些功能其實是原本不需用到的。

TDD 同時也幫助設計出易用的介面，透過寫測試程式的過程，
可以釐清程式的使用方式。
當發現程式不好測試時，通常意味著程式設計不良。
測試程式也可以當作文件使用，
提供使用程式的範例程式碼。

除此之外，在 TDD 的過程中，開發的速度很順暢，
很少會落入長時間的除錯裡，因為程式被強迫切成許多小單位，
並且每一單位都有被測試。
一但出錯馬上會發現，而且知道錯在那裡。
不像以往得用 debugger 追個老半天，
最後發現 bug 在很遠的一小段程式碼裡，有時還是簡單的打錯字。
在除錯的過程，藉由自動化測試的幫助，修改和執行可以快速地反覆交替進行，
減少除錯以外的精神損耗（如手動準備執行需要的資料、設置和操作 debugger ）。
即使寫測試程式花的時間和除錯一樣多（我相信會是較少），
至少以 TDD 的方式進行，心情會比較愉快，不會卡在一個地方太久。

TDD 的個案心得
以我最近的實作案例來說，我一開始知道會用到數個算數函數，而
且這些函數日後需要抽換為不同的算法，方便我比較何種組合效果最好。
舉例來說，我需要實作排序演算法 Sort()，由於資料分佈特性的改變，
我可能需要實作各種演算法如 quick sort、heap sort、insertion sort、
radix sort 等，並讓這些演算法的輸入輸出介面一致，
方便視情況抽換不同的演算法。在這個案例裡，
我需要寫多個這類型的演算法，把它們整合成一個較大的程式。

若照我原本的習慣，大概就全部套 strategy pattern，
於是我可能會先寫數個 interface 或是寫個 abstract class 再套多型。
至少會花半天完成這些工作，並且增加一堆「未來可能會用到」的 class。
但這回我忍住了，我遵從 TDD 的三個步驟，我先統統用 static method 寫，
因為這是最簡單的實作。結果寫個兩天後，我發現這幾個算數函數，
其實只有一個真的需要套 strategy pattern，其它用 static method 就夠了。
也許那一個最複雜的函數也不需用到 strategy pattern，總之，
由於目前仍無需求，我全部都保留原樣。於是我將時間花在刀口上，
優先完成必要的事。
並且，我的 class space 沒有被一堆「也許有用」的 interface 和 class 汙染，避免 over-design，提高整體的可讀性。

相信大家看到這都會大喊，全部都等用到才寫，
日後難道不會付出更大的代價做變動？
改程式碼的代價很高，所以應該多費些心力設計好才對吧？
但別忘了，「改程式碼的代價很高」是一般的情況，
在有充沛的測試程式做為後盾的情況下，改程式的代價其實沒那麼高。
況且，程式碼隨時都有重構，程式應該是保持在容易修改的情況，
改程式的代價又更低了。

至於初期的設計要精確到什麼程度才開始寫程式，
仍需經驗拿捏。我目前的作法是先有個大概的整體設計，
再開始用 TDD 的方式實作各個 class，並完成細部的設計。

