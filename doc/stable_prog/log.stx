日誌系統(log)
=============
0990323

日誌功能
--------
日誌功能雖然簡單，甚至對一般人而言或許不覺得重要，
日誌已成為一個安全的電腦系統不可獲缺的基本元件，具有下列功能：

輔助系統除錯:
  當系統發生問題時，系統日誌是追尋問題唯一的線索和依據。
  我們可以透過這些日誌檔找出系統可能的錯誤，
作為稽核使用:
  或在系統被入侵時找出可能的來源，並藉以協助評估系統損害的範圍，
  作為擬定系統復原程序或向外求援的重要依據。

  甚至可以做為証物，以取得賠償或保險理賠，
  或做更進一步系統安全性的研究。雖然系統日誌能夠留下如此完整的記錄，
  但確經常遭到破壞而無法使用。因為大部份的入侵者在侵入系統作案之後，
  都會設法破壞或修改系統日誌檔，以消滅或掩蓋入侵的痕跡，
  使事後無法追查。如果能夠找到方法來確保系統日誌的完整性，
過濾使用者訊息:

使用者不需要知道的訊息
----------------------
0990316

發生例外時，若只會碰出請「發生系統錯誤，請聯絡資訊室」，對資訊室人員而言，他完全不曉得發生什麼例外，所以記錄所有例外訊息，對修改程式助益甚大。
建議加入以下源碼：

catch(Throwable e){
String msg = "XXX程序未完成:"+e.getMessage();
log.error(msg);
throw new RuntimeException(msg, e);
}


以上兩個link是Python的logging system，寫的算是詳細，
要注意的是%(asctime)-24s
這裡的24表示長度是24不滿的部份補空白，超過就以超原本的長度為主
第一個link裡有寫，不過要狠認真看
也可以做logging server，專門收所有的log，這倒是狠有意思....只要做service的，應該都要有一套這個，好追蹤。
當然網路斷線也沒關係，logging system有支援兩種以上的log，可以本機有log，也可以送到logging server，只是fail over的機制就得自己想了....
----------------------------------------------------------------------------
Update:
http://bytes.com/forum/thread23499.html
試了一下SMTPHandler，發現每一個error就寄一封信，原來要有MemoryHandler，這實在是太神奇了，一定要記下來，不然怎麼猜得到
----------------------------------------------------------------------------
Update:
後來發現這樣如果是發生Error要寄出email不可行，所以只好改用BufferingSMTPHandler
，有興趣可以參考以下link
http://www.red-dove.com/python_logging.html


階層

Log4j將輸出訊息分成五個等級，分別為DEBUG、INFO、WARN、ERROR、FATAL，在上面設定檔將輸出等級 設為INFO，就表示INFO~FATAL等級的訊息將會輸出，因此DEBUG等級的訊息就會被忽略，如果將設定檔的 第一行改為log4j.rootLogger=DEBUG, A1, A2，就會兩個訊息都輸出了。除了這五個等級外，也可以設為ALL或OFF， ALL很示全部訊息都輸出，OFF則表示不輸出訊息。
輸出格式

# %c 輸出日誌訊息所屬的類別的全名
# %d 輸出日誌時間點的日期或時間，指定格式的方式：%d{yyy-MM-dd HH:mm:ss }。
# %l 輸出日誌事件的發生位置，即輸出日誌訊息的語句處於它所在的類別的第幾行。
# %m 輸出訊息，如log(message)中的message。
# %n 輸出一個列尾符號。
# %p 輸出優先階層，即DEBUG，INFO，WARN，ERROR，FATAL。如果是調用debug()輸出的，則為DEBUG，依此類推。
# %r 輸出自應用啟動到輸出該日誌訊息所耗費的毫秒數。
# %t 輸出產生該日誌事件的線程名。
# %r 輸出自應用啟動到輸出該日誌訊息所耗費的毫秒數。
# %f 輸出日誌訊息所屬的類別的類別名。
值得注意的是A2的appender被設為org.apache.log4j.DailyRollingFileAppender表示Log4j會將日誌檔依日期分開。


SECTION 01 前言 

當你在開發程式的時候, 除錯(debugging)和日誌(logging)都是非常重要的工作, 但是, 現在有太多的 logging API 問世, 因為他們都不錯, 很難做一個抉擇. 國外 java 論壇對於這些 logging 方式也是有一番討論. 而 common logging 就是一個在這幾個不同的 logging API 中建立小小的橋樑.


目前在 Java 中最有名的 Log 方式, 首推是 Log4j, 另是 JDK 1.4 Logging API. 除此之外, 還有 Avalon 中用的 LogKit 等等 . 而 commons-logging 也有實作一些基本 的 logging 方式為 NoOpLog 及 SimpleLog. 對於他們的比較不在這次討論範圍,有興趣者請自行參閱參考文件. 


SECTION 02 快速使用 Logging 
其實 logging 非常簡單去使用, 將 commons-logging.jar 放到 /WEB-INF/lib 之下.
接著寫以下的程式碼
LoggingTest.java

package com.softleader.newspaper.java.opensource;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

public class LoggingTest {

	Log log = LogFactory.getLog(LoggingTest.class);


	public void hello() {
		log.error("ERROR");
		log.debug("DEBUG");
		log.warn("WARN");
		log.info("INFO");
		log.trace("TRACE");
		System.out.println("OKOK");
	}
}

		
在 / 放置一支 jsp 測試 
test-commons-logging.jsp

<%@ page import="com.softleader.newspaper.java.opensource.LoggingTest" %>

<%
	LoggingTest test = new LoggingTest();

	test.hello();

%>
		
你將會看到 tomcat console 會有下面輸出 

log4j:WARN No appenders could be found for logger (com.softleader.newspaper.java.opensource.LoggingTest). 
log4j:WARN Please initialize the log4j system properly.
OKOK


是因為你還沒有設定 commons-logging.properties, 馬上會為你介紹 ~~~. 


SECTION 03 設定 commons-logging.properties 
你可以設定你的 log factory 是要使用哪一個 
我以 Log4J 為例子 
在 /WEB-INF/classes/commons-logging.properties 中寫入 

org.apache.commons.logging.Log=org.apache.commons.logging.impl.Log4JCategoryLog
		
如果你 server 是使用 jdk1.4 以上的版本 
可以使用 org.apache.commons.logging.impl.Jdk14Logger


接著根據你的 Logger 撰寫符合他的 properties 
拿 Log4j 為例子 
你就要在 /WEB-INF/classes/ 下擺一個 log4j.properties

log4j.rootLogger=DEBUG, A_default

log4j.appender.A_default=org.apache.log4j.RollingFileAppender
log4j.appender.A_default.File=c://log/test.log
log4j.appender.A_default.MaxFileSize=4000KB
log4j.appender.A_default.MaxBackupIndex=10
log4j.appender.A_default.layout=org.apache.log4j.PatternLayout
log4j.appender.A_default.layout.ConversionPattern=%d{ISO8601} - %p - %m%n
		
		
此時你去執行 test-commons-logging.jsp 輸出的內容, 就會記錄在你的 c:\log 目錄的 test.log 中了 

ps:如果沒有相關的 class 會使用到 SimpLog, 此時要設定的是 simplelog.properties 


SECTION 04 結論
以我自己本身使用的經驗, Log4j 可以滿足所有工程師, 所以我也是直接使用 log4j 而沒有使用 commons-logging. 不過為了增加產品的共用性, 避免移植時候的麻煩, 新的產品及專案, 我會將他改成 commons-logging api 去呼叫. 才能符合真正的 reusable , 減少工程師未來的負擔.

簡介 :
Log4j 是一套開放源碼的工具,方便編程人員在程式中加入 log 機制,並輸出到各種目標上。Log4j 能夠透過外部的設定檔(properites 或 XML)進行設定。Log4j 能夠將 log message 寫到 console, 檔案,串流,TCP 協定的伺服器, Unix Syslog daemon 等。Log4j 具有 5 種 log 層級(DEBUG, INFO, WARN, ERROR, FATAL),可用於不同的系統狀態下所產生的訊息。

組成 Log4j 的三大元件 :

Logger - 由編程人員在程式中使用,進行 logging 的元件
Appender - 負責將 log message 輸出到各種裝置上
Layout - 決定 log message 的格式
Log4j 的階層架構 :
一個程式中可以擁有多個 Logger,這些 Logger之間以名稱區分,並以此區分出階層。例如有一個 Logger 的名稱為 "com.foo",那麼另一個名為 "com.foo.bar" 的 Logger 就隸屬於 "com.foo" logger,如果 "com.foo.bar" 未定義自己的 log 等級,則以 "com.foo" 的 log 等級為預設值。

階層的最高為 root logger。Root logger 一定在存,不具有名稱屬性,可以隨時在程式中以 Logger.getRootLogger() 取得,其它 logger 則以 Logger.getLogger(String loggerName) 取得。

Logger :
Logger 可以被指派等級。能夠指派給 Logger 的等級有 : DEBUG, INFO, WARN, ERROR, FATAL 5 種,定義在 org.apache.log4j.Level 類別中。這 5 種等級的高低順序為 FATAL > ERROR > WARN > INFO > DEBUG。

Logger 的等級決定它產生 log message 的數量 : Logger 只寫"出高於或等於本身等級"的 log message。例如某個 Logger 的等級被設定為 WARN,那麼它只會寫出等級為 WARN, ERROR, FATAL 的 log message,對於 DEBUG, INFO 的 log message 則不予理會。

若是 Logger 的等級未被設定,則會自動使用 parent(上一層) 的等級。如果程式中所有的 Logger 都未設定等級,則由 root logger 決定。

Logger 之間以名稱區分,所以在程式中任何地方,呼叫 Logger.getLogger(),並傳入同一個 Logger 名稱,則會得到同一個 Logger 的 reference。

Logger 之間以名稱區分出階層。即使父階層在程式中出現的時機比子階層晚,例如 "com.foo" logger 比 "com.foo.bar" 被取得的時間來得晚,"com.foo" 仍然是 "com.foo.bar" 的父階層(會影響到子階層 logger 未被定義的屬性, log 等級, appender, layout )。

Appender:
透過 Appender, Logger 能夠將 log message 輸出到指定的裝置上。一個 Logger 能夠擁有多個 Appender,所以 Logger 能夠同時將 log message 輸出到多個個裝置上。

Appender 的設定亦會反映在 Logger 的階層中。當 Logger 輸出一筆 log message 時,父階層的 Appender 和自己的 Appender(如果有的話)都會記錄到這筆 log message;例如 "com.foo" Logger 有一個 Appender 將 log message 輸出到 console,而 "com.foo.bar" 有一個 Appender 將 log message 輸出到 檔案;當 "com.foo.bar" Logger 輸出一筆 log message 時, console 和檔案都會出現這筆 log message。而最簡單的例子,就是當 root logger 擁有一個輸出到 console 的 Appender 時,則程式中所有的 logger 所產生的 log message 都會輸出到 console。唯一個例外的情況,就是當某個 logger 將自己的 additivity 屬性設為 false(Logger.setAdditivity(false)),則此 logger 與隸屬於它的子 logger 都不會將 log message 寫到 console。

Layout:
編程人員透過 Layout 的配置,能夠自由改變 Logger 寫出 log message 的格式。例如,為 Logger 加入一個 conversion pattern 為 "%r [%t] %-5p %c - %m%n" 的 PatternLayout,則輸出的 log message 就可能會像下列這樣:

176 [main] INFO  org.foo.Bar - Located nearest gas station.
PatternLayout 的 格式字元列表如下:

%c 輸出日誌訊息所屬的類別的全名
%d 輸出日誌時間點的日期或時間，指定格式的方式：%d{yyy-MM-dd HH:mm:ss }。
%l 輸出日誌事件的發生位置，即輸出日誌訊息的語句處於它所在的類別的第幾行。
%m 輸出代碼中指定的訊息，如log(message)中的message。
%n 輸出一個列尾符號。
%p 輸出優先階層，即DEBUG，INFO，WARN，ERROR，FATAL。如果是調用debug()輸出的，則為DEBUG，依此類推。-5p 代表將此字串填滿至 5 個字元,以空白補不足處。
%r 輸出自應用啟動到輸出該日誌訊息所耗費的毫秒數。
%t 輸出產生該日誌事件的線程名。
%f 輸出日誌訊息所屬的類別的類別名。
Layout 亦會反映在 Logger 的階層上。


設定 :
設定 Log4j 有 2 種方式 : 以 Java 程式碼配置組態,或是以外部設定檔進行設定。無論以哪種方式進行,不外下列幾個主要的步驟:

定義 Root Logger 的等級 - 此設定會成為 logger 的預設等級
定義 Root Logger 的 Appender - 如果有定義 Root Logger,則 Root Logger 的 Appender 一定要指定
定義 Root Logger Appender 的 Layout - 定義 Layout 的類別後,可以選擇是否要定義該 Layout 的 conversion pattern
定義個別的 Logger,其它步驟同 Root Logger
最簡單的使用方式 - 使用 BasicConfigurator 進行設定, Root Logger 將會被設定為 DEBUG 等級,並且將 log message 以 "%r [%t] %p %c %x - %m%n" 的格式輸出到 console :

package yc.usingLog4j;

import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.Logger;

public class UsingLog4j {
     private static Logger logger = Logger.getLogger(UsingLog4j.class);

     public static void main(String[] args) {
     BasicConfigurator.configure();

     logger.info("This is an info message.");
     logger.debug("This is a debug message.");
 }
}
將 Log4j 的設定提到外部檔案(*.properties),讓程式較具有彈性。以下是一個設定檔的範例 :

#定義 Root Logger 的等級為 INFO,且為其指定一個 appender 名為 rootAppender.
log4j.rootLogger=info, rootAppender

#指定 rootAppender 的類型.
log4j.appender.rootAppender=org.apache.log4j.ConsoleAppender

#指定 rootAppender 的 Layout.
log4j.appender.rootAppender.layout=org.apache.log4j.PatternLayout

#指定 rootAppender Layout 的輸出格式.
log4j.appender.rootAppender.layout.ConversionPattern=%d [%t] %-5p %c - %m%n

#設定特定名稱的 Logger.
log4j.logger.yc.usingLog4j.UsingLog4jA=INFO, log4jaAppender
log4j.appender.log4jaAppender=org.apache.log4j.RollingFileAppender
log4j.appender.log4jaAppender.File=d:/tmp/usinglog4j.log
log4j.appender.log4jaAppender.MaxFileSize=100KB
log4j.appender.log4jaAppender.MaxBackupIndex=10
log4j.appender.log4jaAppender.layout=org.apache.log4j.PatternLayout
log4j.appender.log4jaAppender.layout.ConversionPattern=%c - %m%n
Log4j 會從 class path 中尋找 log4j.properties,並自動讀取其中的設定。

一般的使用方法 : 為 Root logger 設定 DEBUG 等級, Appender 及格式。其它的 logger 不做其它設定;當程式要轉換為 debug 或 release 模式時,只需修改 Root Logger 的等級即可。


使用範例 :

package yc.usingLog4j;

import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;

public class UsingLog4j {
  private static Logger logger = Logger.getLogger(UsingLog4j.class);

  public static void main(String[] args) {
      BasicConfigurator.configure();
    
      /* 改變 Root Logger 的等級為 INFO */
      //Logger.getRootLogger().setLevel(Level.INFO);
    
      /* 鴨子類別庫的 client 只做 INFO 等級的 log;類別庫裡才使用 DEBUG 等級的 log. */
      logger.info("Create a Redhead Duck.");
      RedheadDuck rhd = new RedheadDuck(new FlyWithWings(), new Quack());
      logger.info("Play with the duck.");
      rhd.display();
      rhd.performFly();
      rhd.performQuack();
    
      logger.info("Create a RubberDuck.");
      RubberDuck rbd = new RubberDuck(new FlyWithRocket(), new Squeak());
      logger.info("Play with the duck.");
      rbd.display();
      rbd.performFly();
      rbd.performQuack();
      }
  }

  interface FlyBehavior {
      public void fly();
  }

  class FlyWithWings implements FlyBehavior {
      private static Logger logger = Logger.getLogger(FlyWithWings.class);
    
      public void fly() {
      logger.debug("Fly with wings...");
  }
}

class FlyWithRocket implements FlyBehavior {
  private static Logger logger = Logger.getLogger(FlyWithRocket.class);

  public void fly() {
      logger.debug("Fly with a rocket...");
  }
}

interface QuackBehavior {
  public void quack();
}

class Quack implements QuackBehavior {
  private static Logger logger = Logger.getLogger(Quack.class);

  public void quack() {
      logger.debug("Quack...");
  }
}

class Squeak implements QuackBehavior {
  private static Logger logger = Logger.getLogger(Squeak.class);

  public void quack() {
      logger.debug("Squeak...");
  }
}

abstract class Duck {
  private FlyBehavior flyBehavior;

  private QuackBehavior quackBehavior;

  public Duck(FlyBehavior flyBehavior, QuackBehavior quackBehavior) {
      this.flyBehavior = flyBehavior;
      this.quackBehavior = quackBehavior;
  }

  public void performQuack() {
      this.quackBehavior.quack();
  }

  public void performFly() {
   this.flyBehavior.fly();
  }

  public abstract void display();
}

class RedheadDuck extends Duck {
  private static Logger logger = Logger.getLogger(RedheadDuck.class);

  public RedheadDuck(FlyBehavior flyBehavior, QuackBehavior quackBehavior) {
      super(flyBehavior, quackBehavior);
  }

  @Override
  public void display() {
      logger.debug("A RedheadDuck is showing up...");
  }
}

class RubberDuck extends Duck {
  private static Logger logger = Logger.getLogger(RubberDuck.class);

  public RubberDuck(FlyBehavior flyBehavior, QuackBehavior quackBehavior) {
      super(flyBehavior, quackBehavior);
  }

  @Override
  public void display() {
      logger.debug("A RubberDuck is showing up...");
  }
}

在一般情況下運行時所得到的 log message :

0 [main] INFO yc.usingLog4j.UsingLog4j  - Create a Redhead Duck.
16 [main] INFO yc.usingLog4j.UsingLog4j  - Play with the duck.
16 [main] INFO yc.usingLog4j.UsingLog4j  - Create a RubberDuck.
16 [main] INFO yc.usingLog4j.UsingLog4j  - Play with the duck.

而在除錯模式下則是 :

0 [main] INFO yc.usingLog4j.UsingLog4j  - Create a Redhead Duck.
109 [main] INFO yc.usingLog4j.UsingLog4j  - Play with the duck.
109 [main] DEBUG yc.usingLog4j.RedheadDuck  - A RedheadDuck is showing up...
109 [main] DEBUG yc.usingLog4j.FlyWithWings  - Fly with wings...
109 [main] DEBUG yc.usingLog4j.Quack  - Quack...
109 [main] INFO yc.usingLog4j.UsingLog4j  - Create a RubberDuck.
125 [main] INFO yc.usingLog4j.UsingLog4j  - Play with the duck.
125 [main] DEBUG yc.usingLog4j.RubberDuck  - A RubberDuck is showing up...
125 [main] DEBUG yc.usingLog4j.FlyWithRocket  - Fly with a rocket...
125 [main] DEBUG yc.usingLog4j.Squeak  - Squeak...

一個非信賴機器上安全系統日誌環境之設計與實作1
馮立琪、邱國政、
黃盈源長庚大學資管系Email:lcfeng@mail.cgu.edu.tw

摘要
~~~~
近年來因為網際網路相關技術日漸成熟，全面帶動了我們走向一個電子化的社會，
使愈來愈多個人機密或隱私的資料存放在電腦當中或是在網路上傳遞。
資訊系統和網路安全成為一個十分重要的課題。
UNIX系統中有許多的日誌檔，用來記錄系統中所發生的各種事件。
當系統發生問題時，系統日誌往往是追尋問題唯一的線索和依據，
但是卻經常遭到刻意的破壞或修改而無法使用。
如果能夠找到方法確保系統日誌的完整性，對系統的安全將有很大的助益。
本論文提出了一個方法，透過作業系統核心的研究與改進來強化系統日誌的安全性。
初步評估顯示，我們的作法比目前利用密碼學的作法有較好的效果，
同時系統在效能上也不會有明顯的降低。
關鍵詞：系統日誌(systemaudit)、系統安全(systemsecurity)

1.緒論隨著資訊技術的蓬勃發展，人類生活的模式發生了很大的變化。
近年來更因為網際網路以及電子商務等相關技術的日漸成熟，
全面帶動了我們逐步走向一個電子化的社會，
愈來愈多個人機密或隱私的資料存放在電腦當中或是在網路上傳遞。
資訊系統和網路安全成為一個十分的重要的課題。
資訊系統及網路安全的研究層面很廣且環環相扣，
都十分重要而缺一不可，需要密碼學、資訊安全、
作業系統以及網路等各領域的研究人員通力合作。
密碼學經過了多年的研究和發展已有了不錯的成果，
綜觀近來所發生的安全問題極少是因為密碼演算法或安全協定出問題，
其原因大都是因為系統有安全上的漏洞、密碼模組設計不良等原因造成。
因此，如何從軟體開發、作業系統以及網路系統本身的角度切入進行研究，
也就更顯的重要。
在UNIX系統當中有許多的日誌檔(logfiles、auditlogs)用來記錄在系統中所發生的各種事件。
從使用者登入、登出及使用的時間、連線所在的位址、使用者執行的指令、
傳送的檔案名稱及大小，到記載一般使用者變更為root的要求、
錯誤的登入嘗試等，以及各種發生於系統、應用程式、甚至是通訊協定層的訊息。

這些logfiles對一般人而言或許不覺得重要，
但它們確是一個安全的電腦系統不可獲缺的基本元件[1][2][3]。
當系統發生問題時，系統日誌是追尋問題唯一的線索和依據。
我們可以透過這些日誌檔找出系統可能的錯誤，或在系統被入侵時找出可能的來源，
並藉以協助評估系統損害的範圍，
作為擬定系統復原程序或向外求援的重要依據。甚至可以做為証物，
以取得賠償或保險理賠，
或做更進一步系統安全性的研究。雖然系統日誌能夠留下如此完整的記錄，
但確經常遭到破壞而無法使用。因為大部份的入侵者在侵入系統作案之後，
都會設法破壞或修改系統日誌檔，以消滅或掩蓋入侵的痕跡，
使事後無法追查。如果能夠找到方法來確保系統日誌的完整性，
除了在必要時能協助我們重建系統或採取相關保護自我權益的行動外，相信對入侵者也會產生一定的嚇阻作用。因此，如何保護系統日誌的安全，也就成了一個重要的研究議題。傳統UNIX系統的日誌檔均被設計成一般的檔案，透過檔案系統來存取，也是利用傳統的使用權限設定來保護。入侵者一旦入侵成功，取得了root的權限，自然有辦法去修改日誌檔的存取權限以達到修改或破壞其內容的目的[7][8]。BruceSchneier和JohnKelsey在1999年提出了他們的相關研究成果[4][5]。他們明確的指出，單憑密碼學的技術並無法阻止系統日誌不被刪除或破壞。在本論文中，我們透過Linux作業系統核心的研究與改進，在一般的untrustedmachine上設計並實作了一個安全的系統日誌環境，使日誌檔無法被竄改。依據效能評估顯示，系統在整體的效能上不會有明顯的降低。2.相關研究在提昇系統日誌安全性的研究上，一般的想法[10][11]是利用一部standalone的電腦做為securelogginghost，該電腦再透過serialline與網路的loghost(可能untrust)相連。loghost因為較可能受到侵害，所以會將其系統日誌透過serialline存到另一部securelogginghost上去貯存。此一方法雖然不錯，但實際上我們還是會有要在一般的untrusted的電腦上貯存系統日誌的需求[4][5]。BruceSchneier和JohnKelsey在1998和1999年發表了相關的研究成果[4][5]，在其研究中假設有一個untrustedmachineμ必須記錄系統的auditlogs，另外有一部trustedmachineτ，而μ不定期的與τ交談，由τ來確認log資料的正確性，他們利用了MACs(MessageAuthenticationCodes)和encryptionkeys等密碼學的方法，對加入log的entry加以處理，確保系統μ在被妥協(compromise)之前所記錄的log可以不被入侵者讀取、或做無法察覺的修改與刪除，所有被修改或刪除的資料會在下一次與τ進行交談時被偵測出。在他們的研究成果中，也提出一個重要的概念，單憑密碼學的技術並無法阻止log不被刪除或遭到破壞。RaySpencer、StephenSmalley和MikeHibler等人[12]，提出作業系統應該對各種securitypolicy提供足夠的支援和彈性。VincenoCutello等人亦提出了相關的研究[6]，他們修改了關於檔案系統的執行、開啟以及存取權限控制的部分程式碼，設下檢查點以查核使用者名稱與權限，達到即便有root權限也只能對日誌檔案進行新增的動作，必須要同時取得root與auditlog管
Page 3
3理者的雙重權限才能夠修改系統日誌的內容。我們認為這樣的做法在日誌系統上並不適當，設下重重關卡作驗證的工作，會使得某些常用的系統動作(operations)執行效能明顯降低，如Netscape效能下降了將近30%左右。另外，auditlog管理者權限也有可能因為其他程式的安全漏洞而遭到盜用，使系統日誌遭到破壞。3.Linux上系統日誌的作法在Linux系統日誌中，我們可以將日誌檔案系統分為兩類：系統層級的日誌檔案與應用程式本身的日誌檔案。系統層級的日誌檔案提供了syslogd(syslogdaemon)做為統一的窗口。應用程式可以選擇自行實作或透過syslog之系統呼叫(systemcall)，使用系統所預設之系統日誌機制(如圖二所示)。因此syslogd會隨時隨地從系統的各處接收記錄log檔案的請求，接著便根據/dev/syslog.conf的設定內容，將需記錄的信息記錄至相對應的檔案系統中。syslogd會記錄許多重要的資訊，如kernelmessage、user-levelmessage、mailsystem、systemdaemons、syslog等。4.系統設計與實作4.1系統設計深究系統日誌容易遭受不法的破壞與修改的原因，大多是因為入侵者利用系統的缺陷以及管理方面的漏洞，進而取得超級使用者的權限(superuser,root,supervisor)，往後系統控制權便落入入侵者的手中。由於UNIX系統的日誌檔案系統被設計為一般的檔案系統，並且使用傳統的檔案管理加以管理、保護，因此一般的入侵者一旦取得root權限之後，便可以很輕易的修改或破壞系統日誌的完整性。因此我們認為一個安全的系統日誌環境必須切入作業系統，由核心提供足夠的支援，以確保日誌的完整性。我們的作法是修改作業系統核心，提供一個透明化系統日誌磁碟(transparentlogdisk)來儲存所有重要的系統日誌檔案。而為了避免其他使用者透過/dev目錄下直接存取該logdisk，因此該transparentlogdisk磁碟裝置將不會出現在/dev目錄之下，當然也不受一般檔案系統的存取與控制。在一般的系統運作模式下，我們的logdisk將被設計為一個append-only的FIFObuffer，不接受一般檔案系統存取的命令如read()、write()，而只能透過我們所新設計的系統呼叫sys_log()來加入新的日誌資訊。任何process(即使取得了root的權限)只能讀取或新增資料，無法更動系統日誌檔上已有的內容。因此，即使入侵者取得了root的權限也無法刪除他在日誌檔上所留下的痕跡。另外，我們將修改作業系統核心，設計出一個維護模式(maintenancemode)。在維護模式下不提供網路的連線，只提供單純而必要的功能，也只能在系統控制台(systemconsole)透過root登錄及日誌維護管理員登錄等兩道驗証方能進入。因為有了如此嚴苛的限制，入侵者幾乎無法進入而破壞日誌的完整性。當然實體破壞所造成的危害不在本研究範圍內。
Page 4
4圖1：Linux預設系統日誌機制在維護模式下，我們系統會提供另一組管理工具，
讓日誌管理員對日誌做清除不需要或舊資料的動作，
日誌管理員也可以在此模式下選擇性的將日誌資料轉存或備份到磁帶或
CDR等貯存媒体上，做長久的保存並清出logdisk上的空間。
為了考量系統長時開機提供服務的需求(無法進入維護模式)，
或logdisk容量不足的情況，
當auditlogmanager發現logdisk
的容量少於管理員自定的最低限度時，
會自動將logdisk前端的資料依序寫入CDR中，
以在logdisk上清出足夠的空間。4.2系統實做為了達成透明化的設計，我們希望針對統一的窗口進行修改。syslogd為應用程式開啟了統一的窗口，採用系統提供之日誌系統的應用程式，只要呼叫syslog()的系統呼叫，即可透過syslogd將必要的訊息記錄至系統日誌中。我們修改了syslogd，當它進行寫入系統日誌的動作時，會利用我們實做的系統呼叫sys_log()，透過我們所設計的日誌管理系統，將欲寫入系統日誌的資料進行寫入logdisk的動作。因此，採用系統提供之日誌系統的應用程式，本身不須要做任何的修改，即可將資訊寫入我們的安全日誌中。我們的系統如圖二所示。4.2.1.透明化設計系統在開機(boot)時，系統會將目前系統中的實體硬碟註冊至/dev之下，以便系統與使用者能夠掛載該實體磁碟內的檔案系統，然而本系統基於安全考量，因此不允許使用者甚至最高使用者能夠從/dev中掛載該logdisk，進而利用檔案系統對logdisk進行修改、刪除的動作，因此我們修改核心中實體磁碟註冊之動作，避免logdisk註冊在/dev之下，使用者無法叫用驅動程式中的函式操控該logdisk。另外，我們也設計了logdisk專用的中斷處理函式(log_ide_intr)，以便處理log磁碟讀寫的動作。
Page 5
5圖2：安全系統日誌機制4.2.2系統呼叫為了本系統的實作，
我們新增了一個系統呼叫sys_log()，
也修改了原有的sys_sync()系統呼叫，
另外也新增了一個log_sync()的核心函式。lsys_log()：sys_log為本系統所新增的系統呼叫，當syslogd將系統日誌寫入相對應的檔案時，
會利用呼叫本systemcall進入logdisksubsystem中，
進而將訊息寫入logdisk中。llog_sync()：當系統關機或系統重新啟動時，
系統核心會呼叫sys_sync函式，將記憶體內的資料儲存，
因此為了避免logdisksystem中緩衝區內的資料遺失，
因此在sys_sync函式中需呼叫新增的log_sys()函式將緩衝區內的資料寫入logdisk中。log_sync()函式中，
則實作將緩衝區以及第0個磁區內的metadata，
寫回系統日誌磁碟中，而在logdisk的第0個磁區內存放的metadata則包含了logdisk之magicnumber與系統日誌的開始位置與結束位置。5.效能評估在我們的系統中，針對系統日誌的寫入動作加以限制，入侵者即使擁有最高使用者權限也無法對logdisk進行覆蓋、刪除或修改的動作，提高了系統日誌的完整與安全性。為了評估本系統是否因為修改日誌系統而造成系統效能的下降，
我們進行了三個實驗。第一個實驗：Boot，為一般Linux開機的程序，
由寫入logfile的時間開始計算直到開機完成等待login為止；第二個實驗：grep，
為尋找字串指令，我們選擇由Linux核心原始碼目錄下開始尋找，
grep–r“sys.c”*計算出指令執行到完成所需的時間；第三個實驗：makekernel，
為編譯核心程式碼的動作，計算從開始編譯至編譯完成所需花費的時間。
實驗的環境如下CPU為PIII800,RAM為256MB,作業系統RedHat7.3kernel2.4.18，
logdisk硬碟之轉速為7200rpm，
實驗的結果如圖三所示。在一般使用者的執行動作中，
如boot、grep(尋找字串及檔案)、makekernelimage中，
從實驗結果可以看出系統效能的影響並不顯著，
平均效能下降的百分比為：boot:0%、grep:0.407%、makekernelimage:7.337%，
相較於VincenoCutello等人所提出相似的研究成果[6](boot:60%、grep:13%、makeauditsystem:20%)，
在效能方面有相當顯著的改善。圖3：系統效能之比較6.結論與未來展望利用系統核心的修改，
本論文針對Linux作業系統上的日誌系統提出了一個安全且有效率的方法，
相較於其它的方法，我們有下列的優點:
(1)不需有一部trustedmachine的假設
(2)不需經過複雜的密碼計算(3)提供更強的保護，解決了傳統密碼學無法防止入侵者針對系統日誌進行修改的缺憾(4)runtimeoverhead極低，不影響系統原有之效能。有了完整的日誌資訊，除了可以對入侵者產生嚇阻作用和必要時作為追蹤或入侵來源的依據外，還可配合各類的分析工具如LogSurfer和SWATCH等，發展出入侵偵測系統(IntrusionDetectionSystem)的雛形，用來偵測異常或是不法的行為。此外，我們也將繼續針對使用的效能及便利性進行更進一步的改良。
