Turing 1936 之論文筆記
----------------------
2013/02/11 週一於娘家

1.a-machine

自動機(automatic machines)指機器之運作完全由狀態決定。

其對比是選擇機(choice machine)，
當運作至模糊狀態時，須由外部操作員作出決定，
機器才能開始運作。

2.symbol

2.1.figure

數字僅含 0 及 1 兩種符號，
又稱為第一類符號(symbols of the first kind)。

2.2.symbols of the second kind

第二類符號是除了 0 及 1 的所有符號，
也就是第一類符號的補集。

2.3.符號是有限

自動機之符號是有限的。

3.m-configuration

機器狀態指機器之內部狀態，
由外界無法觀察到。

利用機器狀態的轉變，
機器可有效的記住之前掃描的符號。

4.table

指令表控制機器的行為，
包含一組有限之指令，
意指機器之行為可以用有限字元來描述。

每條指令有 4 個欄位：
分別為機器狀態、掃描符號、操作及最終機器狀態，

機器狀態、掃描符號描述狀態，
而操作及最終機器狀態描述行為。

4.1.標準指令表
義仁 2013/02/15 星期五 

標準指令表中每條規則有 5 個欄位。

qi Sj Sk M ql 

分別表示機器狀態為 qi 、掃描符號為 Sj，
下一步動作為印出 Sk、移動指令為 M ，機器狀態轉換為 ql。

移動指令 M 有三種情形如下表：
R 右移
L 左移
N 不移動

4.1.1.qi

qi 表示第 i 個狀態。

預定狀態如下表：

q1 初始狀態

4.1.2.Si

Si 表示第 i 個符號。

預定符號如下表：

表示 符號
S0   空格
S1   0
s2   1

4.1.3.刪除操作

刪除操作 E 以 PS0 表示。
如下例：
qi Sj E  ,R qm
qi Sj PS0,R qm

4.1.4.移動操作

移動操作以印出掃描符號後移動表示。
如下例：
qi Sj     R qm
qi Sj PSj,R qm

5.skeleton table

在骨架表中，大寫德文為狀態變數，小寫希臘文為符號變數。

5.1.f(C, B, α)

找第一個符號 α，
若找到後轉入 C；
若沒找到則轉入 B。
名字應取自 first。

f (C, B, α) @     L f1(C, B, α)
            not @ L f (C, B, α)

f1(C, B, α) α       C
            not α R f1(C, B, α)
            None  R f2(C, B, α)

f2(C, B, α) α       C
            not α R f1(C, B, α)
            None  R B

5.2.g(C, α)

找最後一個符號 α，
若找到後轉入 C。

命名應源自 go。

g (C)    Any   R g (C)       移到最後一格，並轉移至狀態 C。
         None  R g1(C)

g1(C)    Any   R g (C)
         None  R C

g (C, α)         g(g1(C, α)) 先移到最後一格，再往回找符號 α

g1(C, α) α       C           往回找符號 α
         not α L g1(C, α)


5.3.f'(C, B, α) 及 f''(C, B, α)

f' 同 f，但是在轉移至 B 前，會先左移一格。
f'' 則會先右移一格

l  (C)       L C              左移一格，命名源自 left。
r  (C)       R C              右移一格，命名源自 right。

f' (C, B, α)   f(l(C), B, α)
f''(C, B, α)   f(r(C), B, α)

6.computing machine

只能印出第一類及第二類符號的自動機稱為計算機。

7.circular{p.233}

circular 機器會進入某個狀態，
此狀態不是停機，就是機器只能不斷印出第二類符號。

8.circle-free{p.233}

機器能不斷印出數字。

9.sequence

數字序列，簡稱為序列，或數列(figures)。

10.sequence computed by the machine

由一台圖靈機所印出的數列稱作機器計算之數列。

10.1.S(M)
義仁老家 2013/02/14 星期四 

非論文，由我所加的定義。

S(M) 表示由機器 M 所印出的數列。

11.number computed by the machine

機器計算之數字為其計算之數列前加一個小數點所表示之實數。

12.computable sequence

可計算數列為能由一台circle-free機器所印出的數列。

12.1.computable number
花蓮 2013/02/19 星期二 

可計算數為其數字能由一台機器所印出的數列，
其不包括所有可定義之數，
但不可列舉。

14.S.D

標準描述(Standard Description)
僅含 A, C, D, L, R, N, ; 之符號列，
用來描述機器之指令表。

每條指令以 ; 符號分隔。

R 右移
L 左移
N 不移動
; 分隔指令

14.3.正規表示轉換為 S.D

qi 由一個 D 後面重覆 i 個 A 表示。

Sj 由一個 D 後面重覆 j 個 C 表示。

15.D.N

Description Number，描述數

S.D 用下面規則所轉成的數列。

A=1
C=2
D=3
L=4
R=5
N=6
;=7

16.滿足數

一個 circle-free 之機器之 D.N。

本論文證明沒有一般方法可決定數字 n 是否為滿足數。

17.M(n)

表示機器 M 其 D.N 為 n。
 
18.U

U 表示通用機器，
在磁帶開始置入任一機器 M 之 S.D，
則 U 可印出和 M 一樣的數序。

這項創舉讓程式表示和資料都可放在同一個紙帶中。

18.1.complete configuration

花蓮 2013/02/19 星期二 

完整狀態包含當時紙帶上所有的符號，
並將狀態列於掃描符號之下。

2 個接續的完整狀態以冒號 ":" 分隔
(本文@為X-SAMPA的國際音標來表示原文之字母)。

 :@@0 0:@@0 0:@@0 0:@@0 0   :@@0 0 1:
b   o     q       q        q      p

18.1.1.C

除了將狀態列於掃描符號之下，
也可掃描符號左方插入一格，並填入機器狀態。
如數列 C：

b:@@o0 0:@@q0 0:... (C)

第二種寫法可於一行記下所有完整狀態，
有理論上之用途。

18.1.2.D.N 表示法

把機器狀態及符號轉成 D.N，
其中機器狀態 o 以 DAA、q 以 DAAA 取代，
而符號 @ 以 DCCC 取代可得表示完整狀態之數列 C1 如下：

DA:DCCCDCCCDAADCDDC:DCCCDCCCDAAADCDDC:... (C1)

18.3.M'

M' 可於 F 格接續印出完整狀態。

18.4.U 可印的符號
花蓮 2013/02/21 星期四 

U 可印的符號如下表：

A
C
D
0
1
u 標記關聯完整狀態之指令印出之符號
v 標記最後完整狀態之狀態前一符號之前的符號列
w 標記最後完整狀態之狀態之後的符號列
x 標記最後完整狀態之狀態前一符號
y 標記關聯完整狀態之指令之最終機器狀態
z

18.5.b

b 在 "::" 後印出 :DA 表示初始狀態，後轉入 anf 狀態。

b                       f(b1, b1, ::)
b1 R,R,P:,R,R,PD,R,R,PA anf

18.6.anf

把最後一個完整狀態的狀態標記為 y，
再轉移至 fom。

長遠看來，anf 會找到最後一個完整狀態關聯的指令，
之後可由標記為 z 的分號，找到指令。
並轉移至 sim。

anf   g  (anf1, :)
anf1  con(fom, y)

18.7.fom

fom 找到最後一個沒有標記 z 之分號 ";" ，
把它標記為 z，並把之後的狀態標記為 x。

等同於把指令表最後一個沒有標記 z 指令的分隔號標為 z，
狀態標為 x。

fom ;           R, Pz, L con(fmp, x)
    z           L, L     fom
    not z nor ; L        fom

18.8.fmp

比較 x 所標記的指令之狀態，
及 y 所標記的完整狀態之狀態，
若一樣則轉移 sim，其它則轉移至 fom。

再去除 x 及 y。

fmp cpe(c(fom, x, y), sim, x, y)

18.9.sim

將要執行的指令之操作標為 u，
而要轉換之狀態標為 y，
再清除 z 標記。 

再進入 mf。

sim                   f'(sim1, sim1, z)

sim1                  con(sim2,)

sim2 A                sim3              
     not A R,Pu,R,R,R sim2               若不是 A 則為操作字元，
                                         標記 u。
                                   
sim3 not A L,Py       e(f, z)            
     A     L,Py,R,R,R sim3               若是 A 則是轉換狀態，標為 y。


18.10.mf

完整狀態被分為 4 部份，

狀態部份不標記，狀態前一符號以 x 標記，
狀態前一符號之前的符號串列第一部分以 v 標記，
狀態之後的符號串列以 w 標記。

最後印出 ":"，再轉移至 sh。

mf                   g(mf1, :)

mf1 not A R,R        mf1
    A     L,L,L,L    mf2

mf2 C     R,Px,L,L,L mf2
    :                mf4
    D     R,Px,L,L,L mf3

mf3 not : R,Pv,L,L,L mf3
    :                mf4

mf4                  con(r(r(mf5)),)

mf5 any   R,Pw,R     mf5
    None  P:         sh


:DCCCDCCDAADCDDC

會被 mf 標記成

:DCCCDCCDAADCDDC:
 vvvvxxx     www

18.11.sh

花蓮 2013/02/22 星期五 

找到 u 標記的印出符號指令，
並於尾端印出 0: 或 1: 之符號。

sh                f(sh1,inst,u)

sh1       L,L,L   sh2

sh2 D     R,R,R,R sh2
    not D         inst

sh3 C     R,R     sh4
    not C         inst

sh4 C     R,R     sh5
    not C         pe2(inst,0,:)

sh5 C             inst
    not C         pe2(inst,1,:)

18.12.inst
2013/02/23 星期六 花蓮  

inst 名稱源自 instruction，
會執行標記之指令，後寫下下一個完整狀態。

inst           g(l(inst1),u)

inst1    α R,E inst1(α)

inst1(L)       ce5(oo,v,y,x,u,w)

inst1(R)       ce5(oo,v,x,u,y,w)

inst1(N)       ce5(oo,v,x,y,u,w)

oo             e(anf)

19.可計算數列是可列舉的

因為每個可計算數列至少對應一個 D.N，
而沒有 D.N 可對應2個以上之可計算數列，
所以可計算數列是可列舉的。

20.可計算數列是不可列舉

假設可計算數列是可列舉的，可作以下定義。

20.1.αn

設 αn 表示第 n 個可計算數列。

20.2.φn(m)

φn(m) 表示第 n 個可計算數列中第 m 個數字。

20.3.β 數列

β 數列第 n 個數字為 1 - φn(n)。

20.4.歸謬法證明 β 數列不可計算
2013/02/13 星期三於高雄義仁村

若 β 數列是可計算的，則設其為第 K 個可計算數列，
可得
1 - φn(n) = φK(n)
令 n = K 則
1 - φn(n) = φn(n)
可得
1 = 2φn(n)
因為 1 不可能為偶數，
故得證。

20.5.

β 數列是否可計算，
等同於是否能以有限步驟完全列舉可計算數列。

是否能以有限步驟完全列舉可計算數列，
等同於是否存在一般方法去判定某數 n 是否為 circle-free 機器之 D.N，
也就是判定 n 是否為滿足數。 

20.7.歸謬法證明 D 機為 circular 

D 機其功能為給定一個 S.D，
則可判定此 S.D 是表示 circular 或 circle-free 之機器。

若為 circular 機器之 S.D 則將其標記 u，
表示不可滿足(源自 unsatisfactory)；

若為 circle-free 機器之 S.D 則將其標記 s，
表示可滿足(源自 satisfactory)。

假設 D 為 circle-free 機器

20.8.β' 數列

β' 數列第 n 個數字為 φn(n)。

20.9.H 機

H 機會以 1, 2, 3, .. , N-1, N, ... 等遞增方式列舉數字，
並作下列處理。

設此步驟已列舉至N ，
H 會先用 D 去判斷該數字 N 是否為滿足數，
若為滿足數，則 R(N) = R(N-1) + 1，

並將 N 轉成 S.D 再用 U 模擬 M(N) 印出其所計算之數列至第 R(N) 個數字，
再把第 R(N) 個數字附加到 β' 數列。

N 不為滿足數時，則 R(N) = R(N-1)。

20.9.1.H 行為

N = 0
R = 0
do 
    N = N+1
    if D(N) == s then
        R    = R + 1    
        Rth = U(N)[R]
        β'   = β' . S
loop

20.9.2.R(Record)

R 這個變數用來記錄共列舉出幾個可計算數。

R 0  = 0
R(N) = R(N-1) + 1 | D(N) == s
       R(N-1)     | otherwise

20.10.K

K 為 H 之 D.N。

20.11.H 無法計算第 R(K) 之數 

當 H 計算第 R(K) 之數字時，
由 H 之建構，可知其為 circle-free 機器，
故 K 應為滿足數，其不能標記為 "u"。

但是若其標記為 "s" 時，
則 H 先利用 U 模擬 M(K) 計算至第 K-1 之數列，
但 M(K) 要求第 R(K) 個數字時，
因為 M(K) = H，
又回到 M(K) 即是 H 的 U 模擬 M(K) 計算至第 K-1 之數列，
如此循環反復，第 R(K) 個數字永遠無法找到，
故 H 為 circular 機器。

21.E

給定任何機器 M 之 S.D 給 E，
E 能判定 M 是否會永遠印出 0。

21.1.Mi
2013/02/14 星期四 義仁

M1 會將 M 所計算之數列 S(M) 前 1 個 0 改成 ()，
原文為 0-bar。

M2 會將 M 所計算之數列 S(M) 前 2 個 0 改成 ()。

Mi 會將 M 所計算之數列 S(M) 前 i 個 0 改成 ()。

21.2.Mi之例子

假設 M 印出下面的數列。
M  = ...AB0 1AB0 0 10 AB...
則 Mi 會印出
M1 = ...AB()1AB0 0 10 AB...
M2 = ...AB()1AB()0 10 AB...
M2 = ...AB()1AB()()10 AB...
M2 = ...AB()1AB()()1()AB...

crunch out
Slang To perform operations on; manipulate or process (numerical or mathematical data)

21.2.F

給定任何機器 M 之 S.D 給 F，
F 能依序印出 M1, M2, ... 之 S.D。

21.3.G

G 接受一機器 M ，並利用 F 印出 M1, M2, ...之 S.D。
再利用 E 測試 M, M1, M2,... 之 S.D，
若 E 判斷輸入之機器永遠不印出 0，則印出 :0:。

G 的行為有三種。
G 會停止，若所有的 Mn 都會印出 0。
G 會不停的印出 0，若 M 不會印出 0。
G 會印出 0 後停止。

21.4.E(G)
2013/02/14 星期四 前鎮娘家

E 判定 G 永遠不會印出 0，
則表示 M 會永遠的印出 0。

E 判定 G 會印出 0，
則表示 M 不會永遠的印出 0。

21.5.G'

G 的行為有三種：
G 會停止，若所有的 Mn 都會印出 1。
G 會不停的印出 1，若 M 不會印出 1。
G 會印出 1 後停止。

21.7.E(G')

E 判定 G 永遠不會印出 1，
則表示 M 會永遠的印出 1。

E 判定 G 會印出 1，
則表示 M 不會永遠的印出 1。

21.8.結合 E(G) 及 E(G')可得出判定 M 是否為 circle-free之機器。

21.9.由前得判定機器不存在，依歸謬法可知 E 不存在。

23.alternative squares
交替格法
前鎮2013/02/15 週五 

Turing 把帶子視為F格及E格交替接續。

23.1.F 格

F 格用在存放計算出的數字。

23.2.E 格

E 格(E squares)指暫存格，E 表示 eraseble。

23.3.mark

F 格 S 緊鄰右一個之 E 格，若其符號為α，
則稱 S 以α標示。

24.簡單操作

簡單操作只能改變正觀察到之方格符號。

24.1.immediately recognisable

直接辨識(immediately recognisable)指正掃描的數字，
或被單一符號標示之數列。

如以下數列：
1u2u3u4v5v6v

123 被 u標示，視為一組；456被v標示視為一組可直接辨識之數列。

25.K 機

將 Hilbert 之函數計算(functional calculus)，限定成使用有限符號，
則可使用自動機 K 找到所有於函數計算中可證明之公式。

25.1.F(x, y)

前鎮2013/02/15 週五 

後繼函數，命名繼承 Gödel 1930 年論文之用法，源自德文 nachfolger。

F(x, y) = y == x + 1

25.2.N(x)

x 為非負整數。

25.3.P

皮亞諾公理

  (E u)N(u) 
& (x)(N(x) -> (Ey) F(x,y))  若 x 為非負整數，必有 y 為其後繼數
& (F(x,y) -> N(y))          若 y 為 x 之後繼數，y 必為非負整數。

25.4.Gα(x)

設 α 是一數列，Gα(x) 指 α 的第 x 位數字為 1。
-Gα(x) 指 α 的第 x 位數字為 0。

25.5.U 定義 α

指 -U 不是可被證明的公式，
且對每個 n 而言，An 或 Bn 其中之一可被證明。

25.6.An

U & F^(n) ->  Gα(u^(n))           (An)

25.7.Bn

U & F^(n) ->(-Gα(u^(n)))          (Bn)

25.8.^(r)

r 個角分符號(prime, ' )序列。

原文註解為 A sequence of r primes is denoted by (r)，
容易誤解為質數序列。

角分符號被稱作 prime 源於誤讀。
因為在20世紀初期，
x' 被讀作 x prime 並不是因為在 x 後跟著一個 prime symbol，
而是因為它是 x'， x'' (x second) 與 x''' (x third) 中的第一個，
這裡 prime 是「最初的」意思。

後來在1950s與1960s年代，術語 prime 開始用於撇號這一類的符號。
現在x''與 x'''在英文中通常讀作"x double prime"與"x triple prime"

25.9.F^(n)

F^(n) = F(u, u') & F(u', u'') & F(u'', u''') &...

25.10.Kα 機

令 α 為可計算數列，修改自 K 機之 Kα 機能計算出 α。

Kα 機分成 n 個階段，
在第 n 個階段中，會找出 α 的第 n 個數字。

第 n-1 個階段結束時，會印出雙引號 :: 於結尾。
第 n 個階段中執行所印出之符號都會在雙引號之右邊。

i.   印出 A 後再印出公式 An 後，再印出 B 再印出公式 Bn。 

ii.  如同 K 機，會開始尋找可證明之公式。

iii. 找到可證明公式後，與 An 及 Bn 比較，
     若與 An 一樣則印出 1，
     若與 Bn 一樣則印出 0。
     若不同於 An 及 Bn 則回到 ii ，再找下一個可證明的公式。

由上述建構可知 Kα 終究會停止，
為 circle-free 機器，α 為可計算之數列。

數列用上述公理所定義的均為可計算之數列，
將計算機之描述用函數計算描述。

不是所有可定義之函數均為可計算數，
由節 8 定義 δ 對角數，則不可計算。

26.定義整數變數可計算函數

26.1.γ

γ 為可計算數列。

26.2.n

n 為整數。

26.3.ξ(γ,n)

為第 n 個 0 至第 n+1 個 0 中數字 1 的個數。



25.12.定義可計算變數可計算函數
     
30.Entschedidungsproblem

證明大綱

i.  存在公式 Un(M) 為真。

ii. 若決定性問題可解，則存在一個機器程序決定 Un(M) 是否可證明。

iii.由引理 1 及 2，
    Un(M) 是否可證明若且為若 0 是否出現在 M 之一些完整狀態中。

iv. M 的一些完整狀態中若出現 0，則存在一個機器程序決定 M 是否會印出 0。

v.  由節 8 之證明 2，得知不存在一個機器程序決定 M 是否會印出 0。

vi. Un(M) 為真，但不可被證明，這意指決定性問題不可解。

30.1.RSi(x, y) 
義仁 2013/02/15 星期五 

此謂詞為在 M 的完整狀態中，在空格 y 的符號是 Si。

30.2.I(x, y)

此謂詞為在 M 的完整狀態中，正掃描到空格 y。

30.3.Kqm(x)

此謂詞為在 M 的完整狀態中，機器狀態為 qm。

30.4.G(x,y) - "x precedes y", not necessarily immediately

x 在 y 之前，不一定相鄰。

30.5.Inst{ qi, Sj Sk L ql} 

此謂詞描述指令為機器狀態為 qi 、掃描符號為 Sj，
下一步動作為印出 Sk，左移一格後，機器狀態轉為 ql。

(x, y, x', y'){ (Rsj(x , y )
                &  I(x , y )
                &Kqi(x     )
                &  F(x , x')
                &  F(y', y )
              ->(  I(x', y')
                &Rsk(x', y )
                &Kqi(x'    )
                &  F(y', z )
                v [( Rs0(x ,z) -> Rs0(x',z))
                  &( Rs1(x ,z) -> Rs1(x',z))
                  &...
                  &( RsM(x ,z) -> RsM(x',z))
                  ]
31.Des(M)

“Description-of-M”.
機器 M 之描述，為 Inst 之邏輯和。

31.1.Q

Q 為以下公式之縮寫：

(x)(E w)(y, z){  F(x,w) 
              & (F(x,y) -> G(x,y)) 
              & (F(x,z) &  G(z,y)->G(x,y)) 
              & [  G(z,x) 
                or (G(x,y) & F(y,z)) 
                or (F(x,y) & F(z,y)) -> (-F(x,z))
                ]
              }

32.Un(M)

此謂詞表示在 M 的一些完整描述中，存在 0 於紙帶上。

Un(M) = (Ex u) [ N(u) 
               & (x)   (N(x)    -> (Ex x')F(x, x'))
               & (y, z)(F(y, z) -> N(y) & N(z))
               & (y)   Rs0(u, y)
               & I(u, u)
               & Kq1(u)
               & Des(M)] 
     -> (Ex s)(Ex t)[N(s) & N(t) & Rs1(s,t)]


