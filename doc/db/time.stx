[time]時間類型
--------------
sql 定義的日期和時間類型，如下表所示。

table.日期/時間類型
名字      儲存空間 描述       最低值       最高值       分辨率
========= ======== ========== ============ ============ ===============
timestamp
[(p)] 
[without 
time 
zone]     8 字元   日期和時間 4713 BC      5874897 ad   1 毫秒/14 位
--------- -------- ---------- ------------ ------------ ---------------
timestamp
[(p)] 
with               日期和時間
time zone 8 字元   含時區     4713 BC      5874897 ad   1 毫秒/14 位
--------- -------- ---------- ------------ ------------ ---------------
interval
[(p)]     12 字元  時間間隔   -178000000年 178000000 年 1 毫秒
--------- -------- ---------- ------------ ------------ ---------------
date      4 字元   只用於日期 4713 BC      32767 ad     1 天
--------- -------- ---------- ------------ ------------ ---------------
time[(p)] 
[without 
time 
zone]     8 字元   一日內時間 00:00:00.00  23:59:59.99  1 毫秒
--------- -------- ---------- ------------ ------------ ---------------
time[(p)] 
with               一日內時間 00:00:00.00+ 23:59:59.99-
time zone 12 字元  含時區     12           12           1 毫秒
========= ======== ========== ============ ============ ===============

精度 
~~~~
time，timestamp 和 interval 接受一個可選的精度 p，
精度指定在秒後面小數點之後保留位數。
預設精度是沒有明確給定， 
對 timestamp 和 interval 而言 p 的範圍是從 0 到 6。

若 timestamp 數值是以雙精度浮點數儲存，
那麼精度的有效限制會小於 6。
timestamp 值是以 2000-01-01 午夜之前或之後以來的秒數儲存的，
而微秒的精度是為那些在 2000-01-01 前後幾年的日期實現的， 
對於那些遠一些的日子，精度會下降。
若 timestamp 以八字元整數儲存，
那麼微秒的精度就可以在數值的全部範圍內都可以獲得。 
不過，八位整數的時戳的日期範圍縮小到 4713 BC 到 294276 ad。

對於 time 類型，
若使用了八字元的整數儲存，
那麼 p 允許的範圍是從 0 到 6，
若使用的是浮點數儲存，那麼這個範圍是 0 到 10。

類型time with time zone 但是整個定義有些方面會導致有問題的用法。
通常 date，time，timestamp without time zone 和 timestamp with time zone
就能提供所需日期時間功能。

日期/時間輸入
~~~~~~~~~~~~~
日期和時間的輸入幾乎可以是任何合理的格式，
對於一些格式，日期輸入裡的月份和日子輸入可能會讓人模糊， 
因此系統支援定義自己預期的這些字串的順序。
把 datestyle 參數設置為 mdy， 就是「月－日－年」的解析，
設置為 dmy 就是 「日－月－年」，
而 ymd 是 「年－月－日」。

請記住任何日期或者時間的字面常數輸入需要由單引號包圍， 
就像一個字面常數字串一樣。

type [ (p) ] 'value'
在這裡可選的精度定義中的 p 是一個整數， 
對應在秒域中小數部分的位數， 
我們可以對 time， timestamp，和 interval 類型定義精度。 
允許的精度在上面已經說明。若在常數定義中沒有定義精度，預設是字面常數值的精度。

日期
~~~~
下表顯示了 date 類型可能的輸入方式。

table.日期輸入例子
例子             描述
================ ======================================================================================
january 8, 1999  在任何datestyle輸入模式下都無歧義
1999-01-08       iso-8601 格式，任何方式下都是199年1月8號，「建議格式」
1/8/1999         歧義，在mdy下是一月八號；在 dmy 模式下讀做八月一日
1/18/1999        在mdy模式下讀做一月十八日，其它模式下被拒絕
01/02/03         mdy 模式下的2003年一月2日； dmy 模式下的 2003 年 2月 1日； ymd 模式下的2001年二月三日；
1999-jan-08      任何模式下都是一月8日
jan-08-1999      任何模式下都是一月8日
08-jan-1999      任何模式下都是一月8日
99-jan-08        在 ymd 模式下是一月8日，否則錯誤
08-jan-99        一月八日，除了在 ymd 模式下是錯誤的之外
jan-08-99        一月八日，除了在 ymd 模式下是錯誤的之外
19990108         iso-8601; 任何模式下都是1999年1月8日
990108           iso-8601; 任何模式下都是1999年1月8日
1999.008         年和年裡的第幾天
j2451187         儒略日
january 8, 99 BC 公元前99年
================ ======================================================================================

時間
~~~~
當日時間類型是 time [ (p) ] without time zone 和 time [ (p) ] with time zone。 
只寫 time 等效於 time without time zone。

這些類型的有效輸入由當日時間後面跟著可選的時區組成。
若在 time without time zone 類型的輸入 中定義了時區，那麼它會被無聲地忽略。

table.時間輸入
例子           描述
============== ==================================
04:05:06.789   iso 8601
04:05:06       iso 8601
04:05          iso 8601
040506         iso 8601
04:05 am       與 04:05 一樣；am 不影響數值
04:05 pm       與 16:05一樣；輸入小時數必須 <= 12
04:05:06.789-8 iso 8601
04:05:06-08:00 iso 8601
04:05-08:00    iso 8601
040506-08      iso 8601
04:05:06 pst   用名字定義的時區
============== ==================================

table.時區輸入
例子  描述
===== =======================================
pst   太平洋標準時間「pacific standard time」
-8:00 iso-8601 與 pst 的偏移
-800  iso-8601 與 pst 的偏移
-8    iso-8601 與 pst 的偏移
zulu  軍方對 utc 的縮寫「譯註：可能是美軍」
z     zulu 的縮寫
===== =======================================

時戳
~~~~
時戳類型的有效輸入由日期和時間組成，
後面跟著一個可選的時區，
一個可選的 ad 或者 BC。
另外，ad/BC 可以出現在時區前面，但這個順序並非最佳的。

因此

1999-01-08 04:05:06

和

1999-01-08 04:05:06 -8:00

是有效值，是相容 iso 8601 。
另外，下面這種使用廣泛的格式

january 8 04:05:06 1999 pst

也受支援。

sql 標準透過 "+" 或者 "-" 是否存在來區分 
timestamp without time zone 和 timestamp with time zone 字面常數。
因此，根據標準，

timestamp '2004-10-19 10:23:54'

是一個 timestamp without time zone， 而

timestamp '2004-10-19 10:23:54+02'

是一個 timestamp with time zone。

timestamp with time zone '2004-10-19 10:23:54+02'

若字面常數不是明確地以 timestamp with time zone 開頭，
sql 將忽略任何字面常數中指明的失去。
因此，生成的日期/時間值是從輸入值的日期/時間字串衍生出來的，並且沒有就時區進行調整。

對於 timestamp [without time zone]，
任何在輸入中定義的時區都被悄悄吞掉。 
也就是說，生成的日期/時間數值是從輸入中明確的日期/時間字串中得出的，並且沒有根據時區調整。

對於 timestamp with time zone，內部儲存的數值總是 utc 「全球統一時間，以前也叫格林威治時間gmt」。
若一個輸入值有明確的時區定義，
那麼它將用該時區合適的偏移量轉換成 utc。
若在輸入字串裡沒有時區定義， 那麼它就假設是在系統的 timezone 參數里的那個時區，
然後使用這個 timezone 時區轉換成 utc。

若輸出一個 timestamp with time zone，那麼它總是從 utc 轉換成目前的 timezone 時區，
並且顯示為該時區的本地時間。 要看其它時區的該時間，
要麼修改 timezone，要麼使用 at time zone 構造「參閱 section 9.9.3」。

在 timestamp without time zone 和 timestamp with time zone 
之間的轉換通常假設 timestamp without time zone 數值應該以 timezone 本地時間的形式接受或者寫出。 
其它的時區引用可以用 at time zone 的方式為轉換定義。

間隔
~~~~
interval 值可以用下面語法定義：

[@] quantity unit [quantity unit...] [direction]

quantity 是一個數字「可能有符號」； 

unit 是 second, minute, hour, day, week, month, year, decade, century, millennium, 
或者這些單位的縮寫或複數； 

direction 可以是 ago 或者為空。
符號 @ 是一個可選的東西。不同的單位以及相應正確的符號都是隱含地增加的。

日期，小時，分鐘，以及秒鐘的數量可以在無明確單位標記的情況下定義。 

比如，'1 12:59:10' 和 '1 day 12 hours 59 min 10 sec' 讀數一樣。

可選的精度 p 應該介於 0 和 6 之間， 並且預設是輸入字面常數的精度。

特殊值
~~~~~~
一般 sql 為方便會定義幾個特殊輸入值， 
值infinity 和 -infinity 是特別在系統內部資料表示的，並且將按照同樣的方式顯示； 但是其它的都只是符號縮寫，在讀取的時候將被轉換成普通的日期/時間值。 「特別是，now 和相關的字串在讀取的時候就被轉換成對應的數值。」 所有這些值在 sql 命令裡當作普通常數對待時，都需要寫在單引號裡面。

table.特殊日期/時間輸入
輸入字串  有效類型              意義
========= ===================== ==========================================
epoch     date, timestamp       1970-01-01 00:00:00+00 (unix 系統零時)
infinity  timestamp             比任何其它時戳都晚
-infinity timestamp             比任何其它時戳都早
now       date, time, timestamp 目前交易時間
today     date, timestamp       今日午夜
tomorrow  date, timestamp       明日午夜
yesterday date, timestamp       昨日午夜
allballs  time                  00:00:00.00 utc
========= ===================== ==========================================
下列 sql 兼容函數也可以用於獲取對應資料類型的目前時間值： 
current_date，current_time， current_timestamp，localtime， localtimestamp。
最後四個接受一個可選的精度定義。 
不過，請注意這些 sql 函數不是被當作資料輸入串識別的。

時區
~~~~
時區和時區習慣不僅受地球幾何形狀的影響，還受到政治決定的影響。
到了19世紀，全球的時區變得稍微標準化了些，但是還是易於遭受隨意的修改，
部分是因為日光節約時間規則。

sql 標準在日期和時間類型和功能上有一些奇怪的混淆。兩個顯而易見的問題是：

date 類型與時區沒有聯繫，而 time 類型時區卻可有可無。 
然而現實世界時區只有在與時間和日期都關聯時才有意義， 
因為時間偏移量「時差」可能因為實行類似日光節約時間制度而在一年裡有所變化。

預設時區用一個數字常數資料表示與utc的偏移「時差」。 
因此，當跨 dst 界限做日期/時間算術時， 
根本不可能把日光節約時間的因素計算進去。

為了克服這些困難，建議使用時區時，
使用那些包含日期及時間的類型。 
建議不要求類型 time with time zone 

在系統內部，所有日期和時間都是用全球統一時間utc格式儲存，
時間在發給客戶前端前由資料庫伺服器轉換成本地時間，使用的是配置參數 timezone 定義的時區。

sql 命令 set time zone 為會話設置時區，
set timezone to 的一個可選的拼寫方式， 更加兼容標準。

內部
~~~~
sql 使用儒略曆法用於所有日期時間計算。
若假設一年的長度是365.2425天時，
這個方法可以很精確地預計/計算從4713 BC「公元前4713年」到很久的未來的任意一天的日期。

19世紀以前的日期傳統「曆法」只是對一些趣味讀物有意義， 
好像沒有充分的理由把它們編碼入日期/時間控制器裡面去。
