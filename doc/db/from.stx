[from]
------
資料表表示式
~~~~~~~~~~~~
資料表表示式表示一個資料表。 
該資料表表示式通常在from子句內，
該子句可以根據需要選用 where, group by和 having 子句。
大部分的資料表表示式只是指向磁盤上的一個資料表，即所謂的基本資料表，
但可以用更複雜的資料表表示式以各種方法修改或組合基本資料表。

資料表表示式裡 where, group by和 
having 子句定義一系列對源自 from 子句的資料表的轉換操作。
所有這些轉換最後生成一個虛擬資料表，
並依表頭定義輸出所需的資料紀錄。

from 
~~~~
from 子句從一個用逗號分隔的資料表引用串列生成一個資料表。

code[from.bnf]
from table_reference [, table_reference [, ...]]
::

資料表引用
~~~~~~~~~~
資料表引用可是資料表名稱或衍生資料表，
比如子查詢，資料表連接，或者這些東西的複雜組合。

若在 from 子句中有多個資料表， 
則資料表會依序 cross join 形成一個衍生資料表，
該資料表之後進行 where，group by 和 having 子句的轉換處理，
並最後生成所有資料表表示式的結果。

資料表別名
~~~~~~~~~~
可給資料表資料表引用一個臨時的名字，
讓其它查詢可簡單引用這此衍生資料表。
這稱為資料表別名。

要建立一個資料表別名，如下式：

from employees as e

或者

from employees as e

as 關鍵字目前沒意義。 alias 可以是任意識別字。

資料表別名的典型應用是給長資料表名賦予比較短的識別字，
好讓連接子句更好讀一些。比如：

code[emp_boss_list.sql].員工對應主管名單  
select e1.name, e2.name as boss
from employees e1 join employees e2 
     on (e1.boss_id = e2.id)
::

別名成為目前查詢資料表引用的新名稱，
且不再能用該資料表最初的名字引用它了。
因此下式是不合法的 sql 語法。

code[alias_cover_ori.sql].
select employees.name 
from employees e
::

括弧用於解決歧義．
下式將連接的結果賦予別名 b：

select * from (masters as a cross join angles) as m

若給join子句附加別名，
則該別名就會隱藏 join 裡其它表名。比如

code[alias_cover_outer.sql].
select e.name
from employees e natural join angles as a
::
是合法 sql，但是

code[alias_cover_outer.sql].
select e.name
from (employees e natural join angles) as a
::
是不合法的，資料表別名 e 在外查詢是看不到的。

[subquery]子查詢
---------------
定義衍生資料表的子查詢必須括弧且賦予一個別名。
比如：

from (select * from table1) as alias_name

此例等效於 from table1 as alias_name。 
更有趣的例子是在子查詢裡面有分組或聚集的時候，
這個時候子查詢不能歸納成一個簡單的連接。
