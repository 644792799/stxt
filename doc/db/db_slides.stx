關聯式模型
==========
SQL 的威力
----------
我發現你們常問的問題，也就是你們不懂的部份，
卻是 SQL 最具威力的一面。

先回憶你們常問的問題，再轉從基礎談起。

子查詢
------
子查詢就是任意的 select 語句，會傳回一個表。

子查詢可以使用外查詢變數，
這些變數在該子查詢的任何一次計算中都起常數的作用。

子查詢(2)
---------
若 civil_services 為全國公職名冊，
下述程式利用 exists 描述本局具公職身份的員工名冊。

如[emp_are_civ.sql]便引用其外查詢的表變數「e」。

code[emp_are_civ.sql].具公職身份的員工名冊
select name
from employees e
where exists
      (select 1
       from civil_services c
       where e.name = c.name);
::

exists 語法
-----------
code[exists.bnf].exists 語法
[not] exists (subquery)
::

exists 接受一個子查詢作為參數，
用來測試子查詢是否產出任何紀錄。
若有結果則條件為真，若無條件為假，
判斷為真時才會繼續執行外查詢。

exists 子查詢執行特性
---------------------
子查詢通常只執行到產生一行為止，
而不是等到產出全部結果才停止。
在這裡寫任何有副作用的子查詢都是不明智的（比如調用序列函數）；
這些副作用是否發生是很難判斷的。

not exists 
----------
not exists 則是相對於 exists，判斷為假才會繼續執行外查詢。

下述程式利用 not exists 描述本局不具公職身份的員工名冊。

code[emp_not_civ.sql].不具公職身份的員工名冊
select name
from employees e
where not exists
      (select 1
       from civil_services c
       where e.name = c.name);
::

exists 慣寫法 
------------
因為結果只取決子查詢是否產生任何紀錄，
而不取決於紀錄內容，
所以子查詢的產出結果表通常是無用的。
因此慣寫法常將子查詢寫成「select 1 form...」的形式，
如[emp_are_civ.sql]

表達全稱量詞
------------
sql 並未提供全稱量詞，
只提供存在量詞 exists，
但可用一個雙重否定律利用 exists 表達全稱量詞。

稅種檔
------
table[taxes].稅種檔
id name  
== ======
 1 地價稅  
 2 土增稅
 3 房屋稅
 4 契稅
 5 印花稅 
 6 娛樂稅 
 7 牌照稅 
== ======

taxes 為稅種檔，紀錄所有應收的稅，

繳稅檔
------
table[tax_payments].繳稅檔
id payer  date     area tax    amount
== ====== ======== ==== ====== ======
 1 李白   0981107  鳳林 地價稅   1000 
 2 李白   0980307  鳳林 土增稅    420 
 3 李白   0980307  鳳林 契稅      320 
 4 杜甫   0980501  花蓮 房屋稅    200
 5 杜甫   0980401  花蓮 牌照稅   7120
 6 杜甫   0980301  花蓮 地價稅    200
 7 蘇軾   0980402  玉里 土增稅    300
 8 蘇軾   0981102  玉里 地價稅    300
 9 蘇軾   0980430  玉里 牌照稅   3060 
10 蘇軾   0980430  玉里 契稅       70
11 蘇軾   0980501  玉里 娛樂稅   4400
12 蘇軾   0980530  玉里 房屋稅    200 
13 蘇軾   0980330  玉里 印花稅   3400 
== ====== ======== ==== ====== ======
tax_payments 為繳稅紀錄檔，紀錄所有繳稅紀錄檔。

所有稅都繳名單
--------------
「所有稅都繳」為全稱量詞句，
以雙重否定律可轉成「不存在一個稅他沒有繳的」存在量詞句，
其程式如下：

code[all_taxes_payers.sql].所有稅都繳名單
select distinct payer
from tax_payments as tp1
where not exists
      (select 1
       from taxes
       where not exists
             (select 1
              from tax_payments as tp2
              where (tp1.payer = tp2.payer)
              and (tp2.tax = taxes.name)));
::

in 語法
-------
code[in.bnf].in 語法
c [not] in (subquery)
c1[,c2,c3...] [not] in (subquery)
::
第一列語法中 c 代表外查詢每次所傳回指定欄值，
傳入的子查詢，必須只為單欄表，其欄型態必須和 c 相同。

若 c 存在子查詢表中，結果為真，否則為假。

in 語法(2)
----------
第二列語法中
c1[,c2,c3...] 代表外查詢每次所傳回的一筆當次紀錄，
並選擇指定欄成為比較紀錄，
傳入的子查詢的欄數，必須和比較紀錄欄數一樣，且各對應欄型態必須相同。
若比較紀錄存在子查詢所傳回表中，
則當次紀錄會加入查詢結果表。

和 EXISTS 一樣，子查詢不會完全執行。

查詢表指定欄位內容重覆的紀錄
----------------------------
in 語法可應用在查詢表指定欄位內容重覆的紀錄。

如下查詢出非單人科室員工名單，
即等同查詢表其欄 dep_id 內容重覆的紀錄。

因為只有局長室僅一人，所以會傳回非局長的所有員工。

code[dep_id_not_unique.bnf].非單人科室員工名單
select name 
from employees
where dep_id in (select dep_id
                 from employees 
                 group by dep_id 
                 having count(*) > 1)
::

in 值組
-------
值組為用括弧括起來且以逗號分隔的單元值串，
可視為單欄表。

code[in_values.bnf].in 值組語法
c [not] in (v1, v2,...)
::

第二列語法應用在(v1, v2,...)所指定的值組，
此語法的比較紀錄只能有一欄，

若 c 存在值組中，結果為真，否則為假。

查詢出鳳林及玉里的繳稅紀錄
--------------------------
如下式查詢出鳳林及玉里的繳稅紀錄。

code[tax_payment_in_area.sql].查詢出鳳林及玉里的繳稅紀錄
select * 
from tax_payments
where area in ('鳳林', '玉里')
::

not in
------
not in 意義如下，
若 c 不存在於所有值組的值中，結果為真，否則為假。

查詢不在鳳林或玉里的繳稅紀錄
----------------------------
如下式查詢出不在鳳林或玉里的繳稅紀錄。

code[tax_payment_not_in_area.sql].查詢不在鳳林或玉里的繳稅紀錄
select * 
from tax_payments
where area not in ('鳳林', '玉里')
::

用 in 取代多個 or 條件式 
------------------------
in 可用來取代多個 or 條件式。

為民服務問卷結果表
------------------
如 questionnaires 為民服務問卷結果表，
各欄意義如下：
* id: 問卷編號
* name: 受訪者姓名 
* ltax: 是否來本局辦理過地價稅？
* litax: 是否來本局辦理過土增稅？
* htax: 是否來本局辦理過房屋稅？
* vtax: 是否來本局辦理過牌照稅？
* atax: 是否來本局辦理過娛樂稅？
* dtax: 是否來本局辦理過契稅？

table[questionnaires].為民服務問卷表
id name   ltax litax htax atax atax dtax
== ====== ==== ===== ==== ==== ==== ====
 1 劉邦      Y     N    Y    N    Y    N
 2 李世民    N     N    N    N    N    N
 3 朱元章    Y     Y    Y    N    N    N
== ====== ==== ===== ==== ==== ==== ====

查詢至少來本局辦過一個稅的受訪者名單
------------------------------------
查詢至少來本局辦過一個稅的受訪者名單程式如下：

code[least_one_tax.sql].查詢至少來本局辦過一個稅的受訪者名單
select * 
from questionnaires
where ltax = 'Y'
      or litax = 'Y'
      or htax = 'Y'
      or vtax = 'Y'
      or atax = 'Y'
      or dtax = 'Y'
::

查詢至少來本局辦過一個稅的受訪者名單(2)
---------------------------------------
可用 in 改寫成下：

code[least_one_tax_with_in.sql].用 in 查詢至少來本局辦過一個稅的受訪者名單
select * 
from questionnaires
where 'Y' in (ltax, litax, htax, vtax, atax, dtax);
::

一般人不知道 c 也可寫成常數，
而值組也可寫成外查詢的欄變數組。

回到基礎
--------
見識到 SQL 的威力，現在回到 SQL 的基礎。

SQL 基礎是關聯式模型，
先來了解什麼是「模型」。

永遠無法說出一張圖
------------------
image[DSCF1252.jpg].妳是否可以讓一個沒看過此圖的人，用說的讓她畫的一模一樣

語言的限制
----------
# 一張圖勝千言萬語
# 再多的語言也不能讓別人看到你所看到的影像
# 真實世界是無限複雜
# 可以用人類語言討論(理解)的東西是有限的

古人早就發現這個現象
--------------------
老子：
  道可道、非常道，名可名、非常名

莊子：
  吾生也有涯，而知也無涯，以有涯隨無涯，殆已

金剛經：
  「如來所說三千大千世界，即非世界，是名世界。」

  「如來說世界，非世界；是名世界。」

  「說法者，無法可說：是名說法。」

  「所言善法者，如來說即非善法，是名善法。」

  「如來說諸心皆為非心，是名為心。」

  「佛說般若波羅蜜，即非般若波羅蜜，是名般若波羅蜜。」

那麼怎樣談論問題
----------------
什麼東西可以幫助我們討論問題?

為什麼要有模型?
---------------
為了理解及討論我們的問題，
必須簡化真實世界成為模型。

地圖
----
image[map.jpg].地圖

航照圖
------
image[pic.jpg].航照圖

為什麼要有模型(續)?
-------------------
你認為航照圖會好找路嗎？

模型是什麼?
-----------
# 一組有限的符號(字)
# 一組有限的符號操作(文法)
# 能表達特定領域的問題
# 真實世界的簡化

四則運算
--------
符號={數字, +, -, *, /} 

文法1=數字 運算子 數字

1 + 3

文法2=除法不可以除以 0 的限制

1/0 不合法

為什麼要有文法 2 來增加文法 1 的複雜度?
模型不是越簡單越好？

模型必須反映真實世界
--------------------
答：因為真實世界沒有除以 0 的事物

模型必須建立在反映真實世界的基礎上。

能反映真實世界的模型稱為「正確」(soundness)模型

呼應真實世界是無限複雜
----------------------
存在「正確」(soundness)模型，
但不存在「完全」(completeness)模型

歌德爾(Gödel)不完全定理(1931)
  沒有能完全表達真實世界的模型

圖靈(Turing)[邱奇(Church)]定理(1936)
  圖靈於發明電腦時，就發現電腦不能完全表達真實世界
  所以電腦及虛擬實境只能有限度地表達這個世界

與古人不同，上述的人用數學證明語言的限制

介面
----
介面可視為模型

合約可視為介面
  合約是有限的字

若兩家廠商能提供合約所定義的服務，
則這兩家廠商可以互換。

身為金主只要知道合約所定義的服務，
不需要知道廠商如何達成這個服務。 

汽車的控制介面
--------------
汽車的控制介面主要有三個元素：

# 方向盤
# 煞車踏板
# 加速踏板

對駕駛而言，只要懂上面三個元素及其操作，
就可以利用汽車到想去的地方。

駕駛不需要知道轉動方向盤時，
汽車的機械裝置怎麼轉動車輪。

模型的層次
----------
若甲模型可以模擬出另一個乙模型，
則甲稱為乙的實作，或甲具有乙介面。

若甲乙都模擬丙，
丁的實作是丙，
甲乙互換不會影響上層模型丁。

底層模型為上層模型隱藏細節，
簡化其上層模型的定義。

資料庫的模型層次
----------------
根據不同的應用需求，資料庫模型通常分成三層模型。
# 外部層
# 概念層
# 內部層

外部層
------
此層模型要能滿足使用者執行業務上所必要的功能，
通常是指使用者可以看到的系統部份，
沒有一定形式的資料表示及操作介介面。

概念層
------
此層模型需能讓資料庫管理師以一致的方法定義、
查詢、插入、更新及刪除資料庫儲存的資料，
目前主流模型是關連式模型，
以表為資料表示形式及操作介面，
資料庫管理師不用去適應其它形式的介面。

內部層
------
主要負責將資料永久的保存在硬體上，
沒有一定形式的資料表示及操作介介面。

此層模型要能處理下列問題
# 那些資料需要加上索引，增進擷取效率。
# 要採用何種內部儲存技術：B+-Tree 或雜湊式的儲存方式？
# 在磁碟上如何將資料叢聚在一起。
# 不考慮與裝置有關的存取細節，如：
  磁碟機有幾軌，大小為何，如何劃分

關聯式模型
----------
關聯式模型包含三個主要項目：
# 表
# 完整性
# 運算子

四則運算的比喻
--------------
table.關聯式模型 vs. 四則運算
關聯式模型 四則運算
========== =======================
表         數字
運算子     加減乘除
完整性     除法不可以除以 0 的限制
========== =======================

表
--
關聯式模型中操作資料的基本元素為表，
表可視為一組紀錄的集合。

table[humans].humans
id name   sex birthday
== ====== === ========
 1 陳水扁   M 19501012  
 2 施明德   M 19410115
 3 呂秀蓮   F 19440606
 4 周美青   F 19521130
== ====== === ========

值
--
值是關聯式模型表達真實世界的最小描述單位，
用來描述紀錄的某個屬性。

如「陳水扁」是一個值，
用來描述 humans 第一筆紀錄的 name 欄，
表示真實世界此人的姓名。

常數
----
用來表示某項值的符號，
且此符號永遠只表示某項值。

如「1」是一個常數，在模型裡永遠表示數值 1 。

如「陳水扁」是一個常數，在模型裡永遠表示字串值「陳水扁」。

型態
----
型態為一群值的集合，可用來定義表中某欄所允許的可能值，
所以表中同一欄具有同型態的值。

性別型態包含兩個值，字元 'M' 及 'F'，
分別表示男性及女性，
對應到人的性別只有男女兩種的事實。

如 humans 中欄 sex 被性別型態限制，值僅能為字元 'M' 或 'F'。

相同型態的物件必需可以比較。

欄
--
欄(column)具有兩個屬性，欄名及型態，

紀錄為字典，而欄名視為鍵，可存取紀錄的某一部份值。

表頭
----
表頭為有限的欄集合，用來定義表的紀錄可分成幾欄，
及每欄所允許的可能值，又稱為綱要(Schema)。

如 humans 的表頭可以下面的欄集合表示：

(id, name, sex, birthday)

紀錄
----
紀錄(record)是表中的一列，
表示一項事實。
每一筆紀錄又可分為多個欄，
每個欄具有一個值，
用來描述紀錄的某個屬性。

如表 humans 用來記錄許多自然人，
每筆紀錄具有 4 欄為(id, name, sex, birthday)
分別用來描述自然人的識別碼、姓名、性別及生日。

紀錄可視為由以欄為鍵值的字典，
令 t1 表示第 1 筆紀錄，
則 t1(id) 則會查出數值 1，
t1(name) 則會查出字串值「陳水扁」。

表限制
------
表具有以下的特性：
# 第一標準式：值必須是單元，無法再分割成其它單元值。
# 型態完整性：同一欄的值要有相同的類型。
# 表不可有重複欄名。
# 欄在表中的次序沒有特定的意義。
# 紀錄在表中的次序沒有特定的意義。
# 表不可以有重複紀錄

第一標準式
----------
值必須滿足一種完整性，就是第一標準式，
限制表所有的值必須為單元值，不可是複合值。

單元值意指無法把它分解成其它值。

第一標準式(2)
-------------
table.departments
id name   boss   member
== ====== ====== ==============================
 1 資訊科 廖美慧 廖美慧, 陳文靈, 郭晶佑, 金叔分
 2 行政科 吳美央 吳美央, 賴力密, 賴怡君, 洪慧貞
== ====== ====== ==============================

表 departments 用來紀錄真實世界的科室，
其欄 id, name, boss 都為單元值，
分別描述科室的識別碼、名稱及科長。

但表示科室成員的 member 欄中不是單元值，
像是資訊室的「廖美慧, 陳文靈, 郭晶佑, 金叔分」字串，
可以再分解成「廖美慧」、「陳文靈」、「郭晶佑」及「金叔分」等四個值，
這就不是單元值。

第一標準式(3)
-------------
由於關聯式模型最小操作單位是表，
所以無法以此模型(SQL)來操作複合值，
必須用其它語言來操作。

當郭晶佑退休時，要用什麼操作表示呢？

第一標準式(4)
-------------
code.update
update departments 
set member = '廖美慧, 陳文靈, 金叔分'
where name = '資訊科'
::

如上述 SQL 必須使用 update 指令來將 member 的字串改成無「郭晶佑」的字串，

而無法以 SQL 的 delete 指令表示「郭晶佑」退休的事實。

第一標準式(5)
-------------
table[1NF_departments].departments
id name   boss   member
== ====== ====== ======
 1 資訊科 廖美慧 廖美慧
 2 資訊科 廖美慧 陳文靈
 3 資訊科 廖美慧 郭晶佑
 4 資訊科 廖美慧 金叔分
 5 行政科 吳美央 賴力密
 6 行政科 吳美央 賴怡君
 7 行政科 吳美央 洪慧貞
 8 行政科 吳美央 吳美央 
== ====== ====== ======

若我們將 member 作單值化後成為上表，
就可以下述操作： 

code.delete
delete from departments where name = '郭晶佑'
::

表示「郭晶佑」退休的事實。
此指令是不是比較直覺。

超鍵
----
超鍵(Superkeys)是表中單欄或一組欄的集合，
超鍵需要滿足唯一性(Uniqueness)，在表中絕不會有 2 列擁有相同值，
只需透過超鍵的識別，就可以在表存取指定的值組。

code.超鍵識別
select * from humans
where id   = 1
and   name = '陳水扁'
and   sex  = 'M'
and   birthday = '19501012'
::

如上述 sql，只會得到一筆紀錄，
因為欄集(id, name, sex, birthday)是表 humans 的超鍵，
給所有超鍵條件，只會得到零或一筆紀錄。

候選鍵
------
在每個表至少擁有一個候選鍵(Candidate Keys)，
候選鍵是一個超鍵，不只滿足超鍵的唯一性，
還需要滿足最小性(Minimality)，最小欄數的超鍵，
在超鍵中沒有一個欄可以刪除，
否則將違反唯一性。
表的候選鍵需要同時滿足唯一性和最小性，簡單的說，
候選鍵是最小欄數的超鍵，所以單一欄的超鍵一定是候選鍵。

在 humans 中，(name, sex)是超鍵，
但並非候選鍵，因為拿掉 sex，name 一樣是超鍵，
因為 name 只有一欄，所以 name 是候選鍵。

主鍵
----
主鍵(Primary Key)是表各候選鍵中的其中之一，
而且只有一個，它是用來唯一定址表中的一筆紀錄。

主鍵就扮演身份證號碼的角色，身份證用來代表一個人，
主鍵代表一筆紀錄。

這是一個經濟代表值，
因為若用一個人的出生年月日、姓名及性別，
也可代表一個人，但不如身份證號碼簡單。

主鍵選擇原則
------------
在眾多候選鍵中如何挑選主鍵，選擇原則如下：

絕對不是空值(實體完整性)：
  候選鍵的欄值不能是空值，
  如果是複合鍵，所有欄都保證不會是空值。

永遠不會改變(Never Change)：
  候選鍵的欄值永遠不會改變。

本身不是識別值(Nonidentifying Value)：
  候選鍵的欄值本身沒有其他意義，與原本資料沒有關係的欄，
  通常是人造欄。

簡短且簡單的值(Brevity and Simplicity)：
  儘可能選擇單一欄的候選鍵。

humans 的主鍵
-------------
humans 的候選鍵如下：
# (id)
# (name)
# (birthday)

但最適合作主鍵的應該是 id。
name 及 birthday 本身都具有意義。

其它
----
替代鍵
  在候選鍵中不是主鍵的其他候選鍵稱為替代鍵(Alternate Keys)，
  因為這些是可以用來替代主鍵的侯選鍵。
組合鍵
  主鍵可以包含一或多個欄。
  當主鍵包含多個欄時，稱為組合鍵(Composite Key)。

  稅務資料庫的管理代碼就是組合鍵。
鍵限制
  鍵限制規定表至少要有一個主鍵。
實體完整性限制
  主鍵不可為空值，因為一個實體至少須滿足能與其它實體區別的限制。

外鍵
----
外鍵(Foreign Keys)是表的單一欄或一組欄的集合，
它的值參考其他表的主鍵，扮演連結表的膠水功能，

外鍵與參考主鍵的欄數必須相等，
參考主鍵中的主鍵如果是單一欄，外鍵就是單一欄，
參考主鍵是組合鍵，外鍵也必須是組合鍵。

外鍵和參考主鍵的型態必須相同，但欄名可以不同，

外鍵在表內不一定是主鍵。

外鍵若參考同一個表的主鍵，稱為遞迴關係。

外鍵可以是空值。

員工隸屬關係
------------
像是員工隸屬那個科室的關係便可用外鍵表示。

table.departments
id name   
== ======
 1 資訊科 
 2 行政科 
== ======

表 departments 用來紀錄真實世界的科室，
欄 id, name 分別描述科室的識別碼及名稱。

員工隸屬關係(2)
---------------
table[employees].employees
id dep_id boss_id name
== ====== ======= ======
 1      1       8 廖美慧 
 2      1       1 陳文靈
 3      1       1 金叔分
 4      2       8 吳美央
 5      2       4 賴力密 
 6      2       4 賴怡君 
 7      2       4 洪慧貞
 8      3    null 林全碌
== ====== ======= ======

表 employees 表來描述員工，
欄 id, name 分別描述科室的識別碼及名稱。
而外鍵 dep_id 表示員工隸屬那個科室的關係。

如 employees 第一筆紀錄中，員工名稱為「廖美慧」，
其 dep_id 為 1，可由此知其部門紀錄的 id 為 1。

查看 departments 中 id 為 1 的科室名稱為「資訊室」，
由此可知廖美慧隸屬於資訊室。

遞迴關係
--------
員工之間的主管關係也可用外鍵表示，
這是一個遞迴關係，因為員工的主管也是員工。

外鍵 boss_id 表示員工主管，
如 employees 第一筆紀錄中，員工名稱為「廖美慧」，
其 boss_id 為 8，可由此知其主管紀錄的 id 為 8。
查看同一表中 id 為 8 的員工名稱為「林全碌」，
由此可知廖美慧主管為林全碌。

參考完整性限制
--------------
所有表的外鍵，其所參考表的主鍵必須存在，
否則為空值，表示未參考任何實體。
  
習題
----
# 請寫出自已系統主檔的表頭？
# 請寫出自已系統主檔的每欄的型態(邏輯上的)？
# 請找出自已系統主檔的主鍵，並說明其是否為組合鍵？
# 你認為身份證號碼適合作為自然人的主鍵嗎？
# 請找出自已系統中一個具有外鍵的表？
# 請找出自已系統具有遞迴關係的外鍵？
# 請測試自已系統如何維持參考完整性？

巢狀 SQL
========

表間的關係
============

摘要資料
========
樞紐分析表
----------

視覺化查詢語言
==============
Query By Example
----------------

Access QBE
----------

