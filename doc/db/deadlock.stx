死結
====
死結是因為多個交易相互鎖定對方需要的資料，
等待的資源被一個懸置交易所佔有，
等待資源的懸置行程無法改變其等待狀態，
而正在等待資源的懸置交易無法改變其等待狀態，

例如：並行控制的更新遺失問題就一定會產生死結

資源配置圖
----------
資源配置圖(Resource Allocation Diagram)，
資源以方型表示，而行程以橢圓表示，
當資源指向行程表示此資源被行程佔有，
當行程指向資源表示此行程要求此資源。
如上圖，行程 P 佔有資源 R，且要求資源 R2。

死結的條件
----------
彼此互斥（Mutual Exclusion）：
  交易對資源的寫入鎖定皆視為互斥鎖定，
  同一時間同一資源只允許一個交易對其做寫入鎖定。

鎖定且等待（Lock and Wait）：
  每個交易皆對某些資源做寫入鎖定，
  並等待其它交易解除該資源的寫入鎖定或讀取鎖定。
  佔有某個資源並等待下個資源

不得插隊（No Preemption）：
  當資源被某個交易做了寫入鎖定，
  別的交易不得強行做寫入鎖定或讀取鎖定。
  資源不可插隊

循環等待（Cyclic Waits）：
  所有交易都在等待其它交易解除寫入鎖定，這些交易的等待情況會造成一個迴圈。

鴕鳥預防法(ostrich)
~~~~~~~~~~~~~~~~~~~
假裝系統不會有死結發生。

死結偵測與復原
~~~~~~~~~~~~~~
允許系統進入死結狀態，並能偵測出死結狀態，並復原之。

資料庫管理系統在一定的間隔時間檢查處於等待狀態的交易，以確定是否產生死結，如果有，強迫交易復原（Rollback）後重新開始。死結偵測的方式可以使用「等待圖」（Wait-for Graph）進行檢查，這種圖形是以各交易為節點，Ti→Tj邊線表示交易Ti在等待Tj鎖定的資料，如果圖形有迴圈就表示產生死結，例如：前述更新遺失問題的等待圖即擁有迴圈，如下圖所示：

死結預防
--------
指限制行程存取資源不能同時滿足死結四條件。

Wait-die演算法
~~~~~~~~~~~~~~
交易 O  比交易 Y 的時戳少，換句話話，O 比 Y 老，
要 O 使用被鎖定中的資源時， 
則A必須等待（Wait）；
反之，若交易B要使用交易A鎖定的資源時，則B必須強迫復原（Rollback），並重新執行（Die），但交易時間仍會以原時間T2進行，可以避免產生饑餓（Starvation），如下圖所示：

Wound-wait演算法
~~~~~~~~~~~~~~~~
當交易A要使用被交易B鎖定中的資源時，則B必須被強迫復原（Rollback），並重新執行（Wound），但交易時間仍會以原時間T2進行，可以避免饑餓（Starvation）問題；反之，若交易B要使用被交易A鎖定中的資料時，則必須等待（Wait），

互斥預防
~~~~~~~~
若資源可共用，則不要互斥，如讀取資料庫表
若資源不可共用，則要維持互斥，如更新資料庫表
不太可能達到互斥預防，因為很多硬體資源是不可共享的

死結避免
--------
銀行家演算法(Banker's Algorithm)

二階段鎖定法
~~~~~~~~~~~~
交易使用二階段來鎖定(Two-phase Locking)與解除資料鎖定，如下：

# 擴展階段（Expanding or Growing Phase）：

  在交易A執行資料庫單元操作前，交易A需要請求所有需要存取資料的互斥鎖定，
  如果有資料已經被交易B鎖定，就等待直到交易B解除資料的鎖定。

# 縮減階段（Shrinking Phase）：

  當交易A執行完操作後，就解除鎖定交易A所有鎖定的資料。

樂觀控制法
~~~~~~~~~~
樂觀控制法（Optimistic Control）是指各交易的資料庫單元操作都百分之一百可以順利執行，
直到交易交付後，資料庫管理系統才檢查是否造成資料庫的不一致，如果有，交易就復原（Rollback）。
