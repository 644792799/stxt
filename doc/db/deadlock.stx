死結(deadlock)
--------------
死結是因為多個交易相互鎖定對方需要的資料，
等待的資源被一個懸置交易所佔有，
等待資源的懸置交易無法改變其等待狀態，
而正在等待資源的懸置交易無法改變其等待狀態，

例如：遺失更新問題就一定會產生死結。

資源配置圖
~~~~~~~~~~
資源配置圖(Resource Allocation Diagram)，
資源以方型表示，而交易以橢圓表示，
當資源指向交易表示此資源被交易佔有，
當交易指向資源表示此交易要求此資源。

code.資源配置圖
(A) -> [R] -> (B)
::

上圖表示資源 R 被交易 B 佔有，且交易 A 要求 R。

死結的條件
~~~~~~~~~~
互斥（Mutual Exclusion）：
  交易對資源的寫入鎖定皆視為互斥鎖定，
  同一時間同一資源只允許一個交易對其做寫入鎖定。

鎖定且等待（Lock and Wait）：
  每個交易皆對某些資源做寫入鎖定，
  並等待其它交易解除該資源的寫入鎖定或讀取鎖定。
  佔有某個資源並等待下個資源

不得插隊（No Preemption）：
  當資源被某個交易做了寫入鎖定，
  別的交易不得強行做寫入鎖定或讀取鎖定。
  資源不可插隊

循環等待（Cyclic Waits）：
  所有交易都在等待其它交易解除寫入鎖定，
  這些交易的等待情況會造成一個迴圈。

鴕鳥預防法(ostrich)
-------------------
假裝系統不會有死結發生。

死結偵測與復原(deadlock detection)
-----------------------------------
允許系統進入死結狀態，並能偵測出死結狀態，並復原之。

資料庫管理系統在一定的間隔時間檢查處於等待狀態的交易，
以確定是否產生死結，如果有，強迫交易復原（Rollback）後重新開始。
死結偵測的方式可以使用「等待圖」(Wait-for Graph)進行檢查，
這種圖形是以各交易為節點，Ti->Tj邊線表示交易Ti在等待Tj鎖定的資料，
如果圖形有迴圈就表示產生死結，

例如：前述遺失更新問題的等待圖即擁有迴圈

死結預防(deadlock prevention)
------------------------------
指限制交易存取資源不能同時滿足死結四條件。

互斥預防
~~~~~~~~
若資源可共用，則不要互斥，如讀取資料庫表
若資源不可共用，則要維持互斥，如更新資料庫表
不太可能達到互斥預防，因為很多硬體資源是不可共享的

死結避免(deadlock avoidence)
----------------------------
銀行家演算法
~~~~~~~~~~~~
銀行家演算法(Banker's Algorithm)是避免死結的一個著名的演算法，
是由 Edsger Dijkstra 在1965年為T
.H.E系統設計的一種避免死結產生的演算法。
它以銀行借貸系統的分配策略為基礎，判斷並保證系統的安全運行。

在銀行中，客戶申請貸款的數量是有限的，
每個客戶在第一次申請貸款時要聲明完成該項目所需的最大資金量，
在滿足所有貸款要求時，客戶應及時歸還。

銀行家在客戶申請的貸款數量不超過自己擁有的最大值時，
都應盡量滿足客戶的需要。

在這樣的描述中，銀行家就好比作業系統，資金就是資源，
客戶就相當於要申請資源的交易。

table.目前可用資源(Available)
A B C D
= = = =
1 5 2 0
= = = =

table.已配置的資源(Allocation)
Alloc A B C D
===== = = = =
p1    0 0 1 4
p2    1 4 3 2
p3    1 3 5 4
p4    1 0 0 0
===== = = = =

table.完成交易所需資源(Max)
Max A B C D
=== = = = =
p1  0 6 5 6
p2  1 9 4 2
p3  1 3 5 6
p4  1 7 5 0
=== = = = =

我們會看到一個資源分配表，要判斷交易是否為安全狀態，
首先先找出它的仍需要多少資源記為 Need，
Need即Max(完成交易所需資源)減去Allocation(已配置的資源)，
計算結果如下：

table[need].完成交易仍需資源
Need A B C D
==== = = = =
p1   0 6 4 2
p2   0 5 1 0
p3   0 0 0 2
p4   0 7 5 0
==== = = = =

然後每個交易配置全都為 finish 旗標，預設為 false，
接下來找出 Need 比 Available 小的。

table.找出安全之交易
   A B C D Aval
== = = = = ==== = = = =
p1 0 6 4 2      A B C D
p2 0 5 1 0 <-   1 5 2 0
p3 0 0 0 2
p4 0 7 5 0
== = = = =

P2 的需求小於可用資源，所以回收它的資源。

table.回收 p2 後的可用資源
  A B C D
= = = = =
  1 5 2 0
+ 1 4 3 2  
  2 9 5 2
= = = = =

此時P2 FINISH 旗標改成 true，表示己完成。
接下來繼續往下找，發現P3的需求為0002，小於能用的2952，
所以資源配置給他再回收

table.回收 p3 後的可用資源
  A B  C D
= = == == =
  2  9  5 2
+ 1  3  5 4  
- - -- -- -
  3 12 10 6
= = == == =

同樣的將 P3 的 false 改成 true
依此類推，做完 P4 -> P1，當全部的 FINISH 都變成 true 時，就是安全狀態。

如果所有過程有可能完成執行（終止），
則一個狀態（如上述範例）被認為是安全的。
由於系統無法知道什麼時候一個過程將終止，或者之後它需要多少資源，
系統假定所有交易將最終試圖獲取其聲明的最大資源並在不久之後終止。

在大多數情況下，這是一個合理的假設，
因為系統不是特別關注每個交易運行了多久（至少不是從避免死鎖的角度）。
此外，如果一個交易終止前沒有獲取其它能獲取的最多的資源，
它只是讓系統更容易處理。

基於這一假設，
該演算法通過嘗試尋找允許每個交易獲得的最大資源並結束
（把資源返還給系統）的交易請求的一個理想集合，
來決定一個狀態是否是安全的。不存在這個集合的狀態都是不安全的。

code.銀行家演算法
while len(ps) > 0:
  found = False
  for p in ps:
    if p.max(r) - p.alloc(r) <= avail(r):
      avail(r) += p.alloc(r)
      ps.delete(p)
      found = True
  if not found: return False
return True
::

wait/die及wound/wait
~~~~~~~~~~~~~~~~~~~~
交易 O 比 交易 Y 先執行，換句話說， O 的時戳比交易 Y 的時戳小，

wait/die
  當 O 要求被 Y 鎖定中的資源時， 
  則 O 必須等待 Y 釋放。

  反之，若 Y 要求 O 鎖定的資源時，
  則 B 必須復原並重新執行，這稱為死亡(Die)，
  但交易時間仍會以原時間進行，可以避免產生饑餓。

wound/wait
  當 O 要求被 Y 鎖定中的資源時， 
  則 Y 必須被復原並重新執行，這稱為傷害(Wound)，
  但交易時間仍會以原時間進行，可以避免饑餓問題；

  反之，若 Y 要求 O 鎖定的資源時，
  則 Y 必須等待 O 釋放。

table.wait/die VS wound/wait
   動作               wait/die wound/wait
===================== ======== ==========
O 要求被 Y 鎖定的資源  O wait    Y die
Y 要求被 O 鎖定的資源  Y die     Y wait
===================== ======== ==========

二階段鎖定法
~~~~~~~~~~~~
交易使用二階段來鎖定(Two-phase Locking)與解除資料鎖定，如下：

#.擴展階段(Expanding or Growing Phase)：

  在交易 A執行資料庫單元操作前，交易A需要請求所有需要存取資料的互斥鎖定，
  如果有資料已經被交易B鎖定，就等待直到交易B解除資料的鎖定。

#.縮減階段（Shrinking Phase）：

  當交易A執行完操作後，就解除鎖定交易A所有鎖定的資料。

樂觀控制法
~~~~~~~~~~
樂觀控制法(Optimistic Control)是指各交易的資料庫單元操作都完成執行，
直到交易交付後，資料庫管理系統才檢查是否造成資料庫的不一致，
如果有，交易就復原。

<d:\stxt\doc\db\starvation.stx>
