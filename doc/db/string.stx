[string]字元類型
----------------
SQL 定義了兩種基本的字元類型： 

table.字元類型
名字                             描述
================================ ======================
character varying(n), varchar(n) 變長，有長度限制
character(n), char(n)            定長,不足補空白
text                             變長，無長度限制
================================ ======================

對 character varying(n) 和 character(n) 而言，
n 是一個正整數，指類型最多儲存 n 字元長字串。 
試圖儲存更長的字串到這些類型的字串裡會產生一個錯誤， 
除非超出長度的字元都是空白，這種情況下該字串將被截斷為最大長度。

若儲存字串的長度比 n 短， 
類型 character 將會用空白填滿不足的長度；
而類型為 character varying 的數值將儲存較短的字串。

若強制將字串轉換成 character(n) 或者 character varying(n)， 
那麼超過長度的字串將被截斷成 n 個字元，而不會拋出錯誤。

char(n) 和 varchar(n) 分別是 character(n) 和 character varying(n) 的別名， 

沒有長度定義 n 的 character 等於 character(1)；

若不帶長度定義 n 的 character varying，
則該類型接受任何長度的字串。 

text 類型，它可以儲存任何長度的字串。 
儘管類型 text 不是SQL標準，但被很多 SQL 資料庫系統支援。

類型 character 字串都用空白填充到指定的長度 n，
並且以這種方式儲存和顯示。
不過填充的空白在語意上並不重要。 
在比較兩個 character 字串時，填充的空白都被忽略，
在轉型成其它字串類時，character 字串空白會被刪除。
但在 character varying 和 text 字串中，
結尾的空白語意上是有含義的。

這些類型的儲存需求是 4 字元加上實際的字串，
若是 character 的話再加上填充的字元。

長字串會自動被系統壓縮， 
因此實際儲存空間需求可能會更少些。
長字串也會儲存在後台資料表裡面，
這樣就不會干擾對短字串值的快速訪問。 
允許儲存的最長字串大概是 1 gb。 

允許在資料類型定義的 n 最大值比這還小。 
修改這個行為沒有甚麼意義，
因為在多字元編碼下字元和字元的數目可能差別很大。 
若您想儲存沒有特定上限的長字串，
那麼使用 text 或者沒有長度定義詞的 character varying，
而不要選擇一個任意長度限制。

這三種類型之間沒有性能差別，
只不過是在使用填充空白的類型的時候增加了儲存尺寸，
通常應該使用 text 或者 character varying。

字串函數和運算子
~~~~~~~~~~~~~~~~
本節描述檢查和操作字串的函數和運算子。 

字串包括 character， character varying，和 text 類型值。
除非另外說明，所有下面列出的函數都可以處理這些類型， 
不過要小心的是，在使用 character 類型的時候，
它的自動填充的潛在影響。
通常這裡描述的函數也能用於非字串 類型，
我們只要先把那些資料轉化為字串資料表現形式就可以了。 有些函數還可以處理位串類型。

SQL 定義了一些字串函數，
它們有指定的語法，
裡面是用某種特定的關鍵字，而不是逗號來分隔參數。 

字串連接運算子  
~~~~~~~~~~~~~~
string || string

「||」為字串連接運算子，如下例：

select 'sql' || ' tutorial' => 'sql tutorial'

bit_length
~~~~~~~~~~
bit_length(string)    

字串所佔的 byte 長度，如下例：

select bit_length('jose') => 32

char_length
~~~~~~~~~~~
char_length(string) 或 character_length(string) 
    
字串中的字元個數，如下例：    

char_length('jose') => 4

octet_length
~~~~~~~~~~~~
octet_length(string) => integer

字串中的字元數

octet_length('jose') => 4

convert
~~~~~~~
convert(string using conversion_name) 

使用指定的轉換名字改變編碼。轉換可以透過 create conversion 定義。
當然系統裡有一些預定義的轉換名字。
參閱 table 9-7 獲取可用的轉換名。    

convert('sql tutorial' using iso_8859_1_to_utf_8)

傳回 unicode (utf-8) 編碼的 'sql tutorial'

lower
~~~~~
lower(string)
    
把字串轉化為小寫

lower('Tom') => tom

upper
~~~~~
upper(string) => text

把字串轉化為大寫。

upper('tom') => TOM

position
~~~~~~~~
position(substring in string) => integer

定義的子字串的位置

position('om' in 'thomas') => 3

overlay
~~~~~~~
overlay(string placing string from integer [for integer])

替換子字串    

overlay('txxxxas' placing 'hom' from 2 for 4) => thomas

replace(char, str1, str2)

position
~~~~~~~~
position(substring in string) => integer

指定的子字串的位置    

position('om' in 'thomas') => 3

substring
~~~~~~~~~
substring(string [from integer] [for integer]) => text     

substr(str, int, int) => text

抽取子字串    

substring('thomas' from 2 for 3) => hom

substring(string from pattern) => text

抽取匹配 posix 正則表示式的子字串    

substring('thomas' from '...$') => mas

substring(string from pattern for escape) => text    

抽取匹配SQL正則表示式的子字串

substring('thomas' from '%#"o_a#"_' for '#') => oma

trim
~~~~
trim([leading | trailing | both] [characters] from string) => text

從字串 string 的開頭、結尾或兩邊
刪除只包含 characters 「預設是一個空白」的最長的字串。

trim(both 'x' from 'xtomxx')i => tom

其它
~~~~
set sqlblanklines on
讓 SQL*plus 可辨識含空白行的字串值
