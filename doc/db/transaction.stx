交易
----
交易(Transaction)是一組資料庫操作的邏輯單元(logic unit)，
一個交易中包含了數個以上資料庫動作(Actions)。
在單一使用者的資料庫(Single-User Database)，
使用者隨意利用交易來修改資料庫中的資料，
而不必顧慮是否有其他使用者也同時修改相同資料。 

然而在多使用者資料庫(Multi-User Database)中，
會有多個交易 同時更新資料庫中相同的資料。

並行指的是系統能同時讓幾個交易同時執行。
且能提高系統的總產量，
但並行地執行這些交易必須保證其結果必須與循序地執行這些交易相同，
這也就所謂的資料一致性。

所在多使用者資料庫中的主要考量為如何做到資料並行性與資料一致性。 

每個交易有三種狀態，分別是初始(Begin)、交易中以及交付(Commited)，
而且必須滿足下列 ACID 條件：

單元性(Atomic)：
  一個交易中包含了數個以上資料庫動作，
  整個交易必須視為一個不可分割的單元。
  交易內的操作，不是全部執行，就是全部不執行。
  若單元內其中一個操作未完成，則整個交易必須回到初始狀態，
  回到初始狀態的程序稱為復原(Recovery, Rollback)。

  也就是說整個交易的所有動作必須全部做完，
  若交易的中間過程有任何錯誤產生時，
  必須撤回(Rollback) 到未執行交易前的原點，也就是整個異動都不做

一致性(Consistency)：
  交易前後資料的必須維持一致，
  但交易的過程中未必保持一致性。

  如：甲轉帳1000到乙的帳戶，這交易包含二大部分：

  銀行由甲帳戶內先扣款1000元 

  銀行將1000元加入乙的帳戶內。

  在這交易前的甲與乙的帳戶金額總和
  一定會和交易後的甲與乙帳戶內的金額總相同。
  雖然在這異動的第一部分動作(銀行由甲帳戶中先扣款1000元)做完後，
  資料庫正處於不一致狀態(因為金額總和少了1000元)，
  但等到第二部分動作(銀行將1000元加入乙的帳戶)，
  資料庫以會保持一致性的狀態。

隔離性(Isolation)：
  對交易外的操作而言，只能看到交易的兩種終止狀態，初始及交付。
  交易執行中所用到的資料或所產生的中間結果，
  都不能透露給其它交易讀取或更改，
  為了資料庫效能，隔離性通常會比較寬鬆。

  例如：甲欲由自動提款機中提款1000元而
  乙欲由自己帳戶中轉5000元到甲的帳戶中，
  若甲的交易先執行，
  則乙的交易必須等待甲的交易交付後，
  才能執行將5000元，增加入甲的帳戶內的動作。
  其中乙帳戶扣款的動作，可與甲的交易同時並行執行，不必等待。

持久性(Durability)：
  一旦交付，則交易狀態會永久保存且不能復原。
  如果交易執行過程都完全正常，且交易被交付(Commit)後，
  無論事後系統發生錯誤，則當系統排除錯誤，恢復正常時，
  原交易被交付的資料仍必須存在。

目前主要有兩種方式實現ACID：
# Write ahead logging，也就是日誌式的方式。
# Shadow paging

交易排程
--------
交易排程是一組交易所有操作的執行順序，在並行系統中，
交易內的操作可能彼此交插執行。

序列排程
~~~~~~~~
一般我們認為正確的交易排程是一個交易緊接著另一個交易循序地執行，
而且不相互交插執行，這稱為序列排程(Serial Schedule)，
用來衡量一個排程是否正確。

一個一致性的資料庫經過任何序列化排程運作後，
該資料庫還是合乎一致性的。

交錯排程
~~~~~~~~~~
交錯排程(Non-serial Schedule)中多個交易同時交錯地執行，
然而個別交易內各動作，仍遵守它在該交易內的先後順序。

可序列化排程
~~~~~~~~~~~~
若一交錯排程 A，其執行結果與任一個序列排程 X 的執行結果相同，
則該 A 稱為可序列化排程(Serializable Schedule)。

假設交易 A 的操作為 A.ops = {opa1, opa2, opa3}，
交易 B 的操作為 B.ops = {opb1, opb2, opb3}，
排程 S1 = {opa1, opa2, opa3, opb1, opb2, opb3} 及
S2 = {opb1, opb2, opb3, opa1, opa2, opa3} 都為序列排程，
都是先執行完一個交易的操作，才執行另一個交易的操作。

I1 = {opb1, opa1, opb2, opb3, opa2, opa3} 則為交錯排程。

雖然我們知道可序列化排程可保證多個交易的執行前後的資料庫的一致性。
但是在實際上從多個交易中找中出一個可序列化排程是不可行的。
主要是因為從眾多的交錯排程找出個可序列化排程太費時間了，
再者即使能找出一個可序列化排程，
但是實際上系統會因考慮資源的運用等問題，而不一定會按照該排程來執行，
而且事實上，我們也無法在執行之前「預知」所有交易。
