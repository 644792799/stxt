[transaction]交易
=================
交易(Transaction)是一組資料庫操作的邏輯單元，
一個交易中包含了數個以上資料庫動作(Actions)。

要控制的資料庫的單元操作只有兩種，如下所示：
# 讀取：從資料庫讀取資料。
# 寫入：將資料寫入資料庫。

在單一使用者的資料庫，使用者可隨意利用交易來修改資料庫中的資料，
而不必顧慮是否有其他使用者也同時修改相同資料。 

多使用者資料庫中，會有多個不同使用者交易更新資料庫中相同的資料，
若交易不能並行，則使用者仍可隨意利用交易來修改資料庫中的資料，
而不必顧慮是否有其他使用者也同時修改相同資料。 

然而多使用者並行資料庫指系統能同時讓幾個交易同時執行，
可能會有多個不同使用者同時交易更新資料庫中相同的資料，
這能提高系統的總產量，
但並行地執行這些交易必須保證其結果必須與循序地執行這些交易相同，
這也就所謂的資料一致性。

所在多使用者並行資料庫中的主要考量為如何做到資料並行性與資料一致性。 

[acid]ACID
----------
每個交易有三種狀態，分別是初始(Begin)、交易中以及交付(Commited)，
而且必須滿足下列 ACID 條件：

單元性(Atomic)：
  一個交易中包含了數個以上資料庫動作，
  整個交易必須視為一個不可分割的單元。
  交易內的操作，不是全部執行，就是全部不執行。
  若單元內其中一個操作未完成，則整個交易必須回到初始狀態，
  回到初始狀態的程序稱為復原(Recovery, Rollback)。

  也就是說整個交易的所有動作必須全部做完，
  若交易的中間過程有任何錯誤產生時，
  必須撤回到未執行交易前的原點，也就是整個異動都不做

一致性(Consistency)：
  交易前後資料的必須維持一致，但交易的過程中未必保持一致性。

  如：甲轉帳1000到乙的帳戶，這交易包含二大部分：

  銀行由甲帳戶內先扣款1000元 

  銀行將1000元加入乙的帳戶內。

  在這交易前的甲與乙的帳戶金額總和
  一定會和交易後的甲與乙帳戶內的金額總相同。
  雖然在這異動的第一部分動作(銀行由甲帳戶中先扣款1000元)做完後，
  資料庫正處於不一致狀態(因為金額總和少了1000元)，
  但等到第二部分動作(銀行將1000元加入乙的帳戶)，
  資料庫以會保持一致性的狀態。

隔離性(Isolation)：
  隔離性是指在執行多個交易時，雖然各交易是同時執行，
  不過各交易之間應該滿足獨立性，也就是說，
  一個交易不會影響到其它交易的執行結果，或被其它交易所干擾

  對交易外的操作而言，只能看到交易的兩種終止狀態，初始及交付。
  交易執行中所用到的資料或所產生的中間結果，
  都不能透露給其它交易讀取或更改。

  為了資料庫效能，隔離性通常會比較寬鬆。

  例如：甲欲由自動提款機中提款1000元而
  乙欲由自己帳戶中轉5000元到甲的帳戶中，
  若甲的交易先執行，
  則乙的交易必須等待甲的交易交付後，
  才能執行將5000元，增加入甲的帳戶內的動作。
  其中乙帳戶扣款的動作，可與甲的交易同時並行執行，不必等待。

持久性(Durability)：
  一旦交付，則交易狀態會永久保存且不能復原。
  如果交易執行過程都完全正常，且交易被交付(Commit)後，
  無論事後系統發生錯誤，則當系統排除錯誤，恢復正常時，
  原交易被交付的資料仍必須存在。

目前主要有兩種方式實現ACID：
# Write ahead logging，也就是日誌式的方式。
# Shadow paging

交易狀態
~~~~~~~~
啟動狀態（Active State）：
  當交易開始執行時，進入啟動狀態，依序執行交易的讀取或寫入等資料庫單元操作。
部分交付狀態（Partially Committed State）：
  當交易的最後一個資料庫單元操作執行完後，就進入部分交付狀態。
交付狀態（Committed State）：
  在成功完成交易進入部分交付狀態後，
  還需要交付系統沒有錯誤，就可以進入交付狀態。
失敗狀態（Failed State）：
  當發現正常執行程序不再能夠執行下去時，
  交易就進入失敗狀態，準備執行復原。
放棄或中斷狀態（Aborted or Terminated State）：
  交易在回復到交易前狀態，取消所有寫入資料庫單元操作影響的資料後，就進入此狀態。

交易排程
--------
交易排程(Schedules)」是在執行一系列並行交易時，
各交易資料庫單元操作和運算的完整執行順序，
且交易內的操作可能彼此交錯執行，
主要是針對寫入和讀取資料庫單元操作的執行順序。

循序排程
~~~~~~~~
循序排程(Serial Schedule)是一種在各交易之間沒有並行性的排程，
而是一個交易緊接著另一個交易循序地執行，
各交易的資料庫單元操作的執行順序並不會「交錯」（Interleaving）執行，
循序排程用來衡量一個排程是否正確。

如[serial_schedule]_就是一個交錯排程。

table[serial_schedule].循序排程
時間 交易A       交易B
==== =========== ===========
t1   A.read(p)    
t2   A.update(p)  
t3               B.read(p)   
t4               B.update(p)
==== =========== ===========

一個一致性的資料庫經過任何序列化排程運作後，
該資料庫還是合乎一致性的。

交錯排程
~~~~~~~~~~
交錯排程(Non-serial Schedule)中多個交易同時交錯地執行，
然而個別交易內各動作，仍遵守它在該交易內的先後順序。

如[lost_update]_就是一個交錯排程。

衝突
~~~~
衝突是發生在兩個交易的資料庫單元操作存取相同資料，
三種資料庫單元操作的衝突情況，如下所示：

都讀取資料：
  讀取資料並不會產生衝突。
一個讀取和一個寫入資料：
  可能產生衝突。
都寫入資料：
  可能產生衝突。

從上述的衝突分析，可以歸納出一個結論，
兩個交易的資料庫單元操作產生衝突需滿足：
# 兩個交易的資料庫單元操作存取同一個資料。
# 兩個資料庫單元操作中，至少有一個是寫入操作。

排程等價
~~~~~~~~
如果兩個排程所有衝突情況的順序是相同的，就表示這兩個排程是「等價的」。

循序圖
~~~~~~
「循序圖」（Serialization Graph）又稱為「先行圖」（Precedence Graph），
也稱為進行檢查，其定義如下所示：

# 為一種有向圖(G)，
# 用來描述排程 S 中各交易的相依性的循序圖，記成 G(S)。
# 在 S 中的每一個交易是 g 的一個節點。
# 如果 S 中擁有兩個衝突的資料庫單元操作 Oi 和 Oj，且 Oi 是在 Oj 之前， 
  則在 G 加上一條邊 Ti -> Tj 來表示。
# 若 G(S) 沒有迴圈，就表示 S 滿足可循序性。

可循序化排程
~~~~~~~~~~~~
若一交錯排程 I，其執行結果與任一個循序排程 S 的執行結果相同，
I 與 S 兩個排程是等價，且 I 稱為可循序化排程(Serializable Schedule)。

雖然我們知道可循序化排程可保證多個交易的執行前後的資料庫的一致性。
但是在實際上從多個交易中找中出一個可循序化排程是不可行的。
主要是因為從眾多的交錯排程找出個可循序化排程太費時間了，
再者即使能找出一個可循序化排程，
但是實際上系統會因考慮資源的運用等問題，而不一定會按照該排程來執行，
而且事實上，我們也無法在執行之前「預知」所有交易。

<d:\stxt\doc\db\concurrent_control.stx>
