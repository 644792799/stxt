值組關聯演算(tuple calculus)
============================
0990418 

Code 為關聯式模型引入值組演算，
作為此模型之描述式資料查詢語言，
後來值組演算成為資料庫查詢語言 QUEL 及 SQL 之基礎。

雖然 SQL 很少忠於最初的關聯式模型及值組演算，
但已成為目前關聯資料庫管理系統之標準查詢語言。

除了值組演算 Code 還引入了更接近於一階邏輯之域演算，
並證明了這兩種演算及關聯式代數在表達能力上是等價的。

若關聯資料庫之查詢語言被稱為「關聯式完備性」，
則表示它們與關聯式代數在表達能力上是等價的。

值
--
值是關聯式模型表達真實世界的最小描述單位，
用來描述值組的某個屬性。

如「陳水扁」是一個值，
用來描述 humans 第一筆值組的 name 欄，
表示真實世界此人的姓名。

域(field)
---------
資料庫存在一組符號集合 D，
其成員 d 為關聯變數可代表傳統的資料庫中的型態，

型態或域為一群值的集合，
可用來定義表中某欄所允許的可能值，
所以表中同一欄具有同域的值。

性別域包含兩個值，字元 'M' 及 'F'，
分別表示男性及女性，
對應到人的性別只有男女兩種的事實。

如 humans 中欄 sex 被性別域限制，值僅能為字元 'M' 或 'F'。

按慣例，相同域的物件必需可以相互比較。

欄(column)
----------
資料庫存在一組符號集合 C，
其成員 c 為關聯變數可代表傳統的資料庫中的欄，
如"name", "author", "address" 等等。

值組
----
給定域 D 及欄名集合 C，D 上之「值組」為偏函數:
t : C → D

t 為以欄名存取值組的某一部份值。

所有值組集合記為 TD。

值組之「定義域」 dom(t) 為 C 之子集。

值組(tuple)可類比為資料表中之一列，表示一項關係。
每一筆值組又可分為多個欄，每個欄具有一個值，
用來描述值組的某個屬性。

如表 humans 用來記錄許多自然人，
每筆值組具有 4 欄為(id, name, sex, birthday)
分別用來描述自然人的識別碼、姓名、性別及生日。

值組可視為由(欄:值)對所組成，
例如 humans 第一筆值組可寫成如下：

(id:1, name:陳水扁, sex:m, birthday:19501012)

值組也可視為由以欄名為鍵值的字典，可存取值組的某一部份值。
令 t1 表示第 1 筆值組，
則 t1(id) 則會查出數值 1，
t1(name) 則會查出字串值「陳水扁」。

關聯變數(relvar)
---------------
一組符號集合 R，其成員為關聯變數可代表傳統的資料庫中的資料表。

我們可以透過關聯變數來取得與其相關之資料表頭及值組集合。

表頭為 C 之子集，
可透過表頭函數 h 取出:
h : r → 2^c

關聯變數也代表一組值組集合，
可通表格函數 db 取得此值組集合:
db : R → 2^TD | dom(t) = h(r).

它映射 R 中之關聯變數到 TD 的有限子集，
滿足以下限制:
dom(t) = h(r)

上式要求關聯中所有值組都應該包含同樣的欄名。

基本關聯是由板塊是域或資料類型建造。

關聯資料庫模型
--------------
「關聯資料庫模型」為三值組 S = (D, R, h)，

D 為域之集合，R 是關聯變數集合，
而給定模式 S = (D, R, h) 最後我們定義「關聯資料庫」為函數

也就是在模式中所定義的那些。

項(term)
--------
現在開始定義如何構造公式構造，

我們假定值組變數的一個無限集合 V。
定義公式要給定一個資料庫模型 S = (D, R, h) 和一個偏函數 type : V -> 2^C，

它定義指派表頭到某些值組變數的「類型指派」。

項式集合
--------
「項式集合」 A[s, type] 規則定義如下:
  若 v 和 w 在 V 中，a 在 type(v) 中而 b 在 type(w) 中，
  則公式「v.a = w.b」在 a[s, type] 中，
  換句話說，「v.a = w.b」為項式。

  若 v 在 V 中，a 在 type(v) 中，
  而 k 在 D 中，為一個值，
  則公式「v.a = k」在 A[s, type] 中，
  換句話說，「v.a = k」為項式。

  若 v 在 V 中，r 在 R 中而
  type(v) = h(r)，則公式「r(v)」在 a[s,type] 中，
  換句話說，「v.a = k」為項式。

項的例子:
  t.age = s.age 表示 t 有一個 age 屬性而 s 有一個 age 屬性並有相同的值

  t.name = "codd" 表示值組 t 有一個 name 屬性並且它的值是 "codd"

  book(t) 表示值組 t 存在於關聯 book 中。

  定義這種項的形式語義要給定在 s 上的一個資料庫 db 
  和一筆值組變數綁定

  val : V -> TD，它映射值組變數到在 s 中的域上的值組:

「V.a = w.b」是真，若且唯若 Val(V)(a) = Val(w)(b)

「V.a = k」是真，若且唯若 Val(V)(a) = k

「r(V)」是真，若且唯若 Val(V) 在 db(r) 中

公式
----
同一階邏輯一樣，
項可用通過邏輯算子∧(與)、∨(或)和¬(非)組合成公式，而且我們可以使用存在量詞(∃) 和全稱量詞(∀)來綁定變數。通過如下規則歸納定義「公式集合」 f[s,type]:
所有在 a[s,type] 中項也在 f[s,type] 中
若 f1 和 f2 在 f[s,type] 中，則公式「f1 ∧ f2」也在 f[s,type] 中
若 f1 和 f2 在 f[s,type] 中，則公式「f1 ∨ f2」也在 f[s,type] 中
若 f 在 f[s,type] 中，則公式「¬ f」也在 f[s,type] 中
若 V 在 V 中，h 是一個表頭而 f 是在 f[s,type[V->h]] 中的一個公式，則公式「∃ V : h ( f )」也在 f[s,type] 中，這裡的 type[V->h] 只是除了映射 V 到 h 之外同於 type 的函數。
若 V 在 V 中，h 是一個表頭而 f 是在 f[s,type[V->h]] 中的一個公式，則公式「∀ V : h ( f )」也在 f[s,type] 中
公式的例子:
t.name = "c. j. date" ∨ t.name = "h. darwen"
book(t) ∨ magazine(t)
∀ t : {author, title, subject} ( ¬ ( book(t) ∧ t.author = "c. j. date" ∧ ¬ ( t.subject = "relational model")))
注意最後的公式聲稱 c. j. date 所寫的所有書籍都有關聯式模型的主題。若不導致歧義，我們通常省略圓括號。
我們將假定在量詞量化於在模式中的域上所有值組的全集之上。給定在 s 上的資料庫 db 和值組變數綁定 Val : V -> td，給出如下公式的形式語義:
「f1 ∧ f2」為真，若且唯若「f1」為真並且「f2」為真，
「f1 ∨ f2」為真，若且唯若「f1」為真或者「f2」為真，或者二者都為真，
「¬ f」為真，若且唯若「f」不為真，
「∃ V : h ( f )」為真，若且唯若存在一個 d 上的值組 t 使得 dom(t) = h 並且公式「f」對於 Val[V->t] 為真，
「∀ V : h ( f )」為真，若且唯若對於所有 d 上的值組 t 使得 dom(t) = h 並且公式「f」對於 Val[V->t] 為真。

查詢
----
最後給定一個模式 s = (D, R, h) 我們定義查詢表達式為:
{ V : h | f(V) }
這裡的 V 是值組變數，h 是一個表頭而 f(V) 是 f[s,type] 中的公式，
其中 type = { (V, h) } 並帶有 V 做它的唯一自由變數。
對 s 上給定資料庫 db 的這種查詢的結果是在 d 上帶有 dom(t) = h 的使得 f 對於 db 為真並且 Val = { (V, t) } 的所有值組 t的集合。

查詢表達式的例子:
{ t : {name} | ∃ s : {name, wage} ( employee(s) ∧ s.wage = 50.000 ∧ t.name = s.name ) }
{ t : {supplier, article} | ∃ s : {s#, sname} ( supplier(s) ∧ s.sname = t.supplier ∧ ∃ p : {p#, pname} ( product(p) ∧ p.pname = t.article ∧ ∃ a : {s#, p#} ( supplies(a) ∧ s.s# = a.s# ∧ a.p# = p.p# ) }

演算的語義和語法限制

域獨立查詢
----------
由於量詞的語義使得它們量化在模式中域上所有值組上，若假定了另一個模式則對一個特定資料庫的一個查詢可能傳回不同結果。例如考慮兩個模式 s1 = ( d1, r, h ) 和 s2 = ( d2, r, h )，帶有域 d1 = { 1 }, d2 = { 1, 2 }，關聯欄名 r = { "r1" } 和表頭 h = { ("r1", {"a"}) }。兩個模式有一個公共實例:
db = { ( "r1", { ("a", 1) } ) }
若我們考慮如下查詢表達式
{ t : {a} | t.a = t.a }
在它在 db 上的結果要麼是在 s1 下的 { (a : 1) } 
要麼是在 s2 下的 { (a : 1), (a : 2) }。
若我們採用域為無限集合，則查詢的結果也會是無限的，這是很明顯的。
要解決這些問題我們將把我們的注意力限制於「域獨立」的那些查詢，
就是說，對一個資料庫的查詢在它的所有模式下都傳回同樣的結果。
這些查詢的一個有價值的性質是若我們假定值組變數取值於所謂的這個資料庫「活躍域」上的值組，
它是在資料庫或在查詢表達式中的至少一筆值組中出現的域的子集，
則查詢表達式的語言不變。
事實上，在很多值組演算的定義中，量詞語義就是這麼定義的，
這使得定義的所有查詢都是域獨立的。

安全查詢
--------
為了限制查詢表達式使得它們只表示域獨立的查詢，
通常引入一個語法概念「安全查詢」。
要確定一個查詢是否為安全的，我們要從查詢導出兩種類型的信息。
首先是變數-列對 t.a 是否綁定到一個關聯或一個常數的列上，
其次是兩個變數-列對是否直接或間接的相等(指示為 t.V == s.w)。
為了推導綁定性，我們引入如下推理規則:
在「V.a = w.b」中沒有變數-列對被綁定
在「V.a = k」中變數-列對 V.a 被綁定
在「r(V)」中所有的對 V.a 被綁定於 type(V) 中的 a，
在「f1 ∧ f2」 中所有的點對都被綁定於要麼 f1 中要麼 f2 中，
在「f1 ∨ f2」中所有的點對都被綁定於 f1 和 f2 二者中，
在「¬ f」中沒有點對被綁定，
在「∃ V : h ( f )」中對 w.a 被綁定，若它被綁定在 f 中並且 w <> V，
在「∀ V : h ( f )」中對 w.a 被綁定，若它在 f 中被綁定並且 w <> V。
為了推導相等性，
我們引入下列推理規則(位於常用的等價性推理規則: 自反性、對稱性和傳遞性之後):
在「V.a = w.b」中 V.a == w.b 成立，
在「V.a = k」中沒有點對相等，
在「r(V)」中沒有點對相等，
在「f1 ∧ f2」中 V.a == w.b 成立，若它要麼在 f1 中要麼在 f2 中成立，
在公式「f1 ∨ f2」中 V.a == w.b 成立，若它在 f1 和在 f2 二者中都成立，
「¬ f」沒有點對相等，
在「∃ V : h ( f )」中 w.a == x.b 成立，若它在 f 中成立並且 w<>V 並且 x<>V，
在「∀ V : h ( f )」中 w.a == x.b 成立，若它在 f 中成立並且 w<>V 並且 x<>V。
我們接著聲稱一個查詢表達式 { V : h | f(V) } 是安全的，若
對於所有 h 中的欄名 a，我們可以得出 V.a 等於一個 f 中的綁定對，
對於形如「∀ w : g ( g )」的所有 f 的子表達式，
我們可以得出對於所有 g 中的欄名 a 我們可以得出 w.a 等於一個 g 中的綁定對，
對於形如「∃ w : g ( g )」的所有 f 的子表達式，
我們可以得出對於所有 g 中的欄名 a 我們可以得出 w.a 等於一個 g 中綁定對。
安全查詢表達式的限制不限制表達能力，
因為所有能被表達出來的域獨立查詢都可以用安全查詢表達式表達。
這可以做如下證明，對於模式 s = (D, R, h)，
給定在這個查詢表示式中常數的集合 k，
值組變數 V 和表頭 h，我們可以為所有的對 V.a 構造一個安全公式，
它帶有 a 在 h 中並聲稱其值在活躍域中。
例如，假定 k={1,2}、r={"r"} 和 h = { ("r", {"a, "b"}) } 
則 V.b 對應的安全公式為:
V.b = 1 ∨ V.b = 2 ∨ ∃ w ( r(w) ∧ ( V.b = w.a ∨ V.b = w.b ) )
接著通過在這個表達式中用到地方對所有變數 V 和它的類型中的欄名 a 增加這個公式，
可以用這個公式來把任何不安全的查詢表達式重寫為等價的安全查詢表達式。這有效的使得所有變數都取值於活躍域之上，若表達的查詢是域獨立的，象已經解說的那樣不改變語義。
