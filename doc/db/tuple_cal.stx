[tuple_cal]值組關係演算
-----------------------
Code 為關聯式模型引人值組演算，
目的是為此模型定義一種描述式資料查詢語言。
它給予資料庫查詢語言 QUEL 和後來的 SQL 建立的基礎，
儘管 SQL 很少忠於最初的關聯式模型和演算，
但現在是所有的關聯資料庫管理系統中的標準查詢語言。

除了值組演算 Code 還引入了更接近於一階邏輯的域演算，
並證明了這兩種演算及關聯式代數在表達能力上是等價的。

若關聯資料庫的查詢語言被稱為「關聯式完備性」，
則表示它們與關聯式代數在表達能力上是等價的。

值
~~
值是關聯式模型表達真實世界的最小描述單位，
用來描述值組的某個屬性。

如「陳水扁」是一個值，
用來描述 humans 第一筆值組的 name 欄，
表示真實世界此人的姓名。

型態
~~~~
型態為一群值的集合，可用來定義表中某欄所允許的可能值，
所以表中同一欄具有同型態的值。

性別型態包含兩個值，字元 'M' 及 'F'，
分別表示男性及女性，
對應到人的性別只有男女兩種的事實。

如 humans 中欄 sex 被性別型態限制，值僅能為字元 'M' 或 'F'。

相同型態的物件必需可以比較。

欄
~~
欄(column)具有兩個屬性，欄名及型態，

值組為字典，而欄名視為鍵，可存取值組的某一部份值。

值組
~~~~
值組(record)是表中的一列，
表示一項事實。
每一筆值組又可分為多個欄，
每個欄具有一個值，
用來描述值組的某個屬性。

如表 humans 用來記錄許多自然人，
每筆值組具有 4 欄為(id, name, sex, birthday)
分別用來描述自然人的識別碼、姓名、性別及生日。

值組可視為由(欄:值)對所組成，
例如 humans 第一筆值組可寫成如下：

(id:1, name:陳水扁, sex:m, birthday:19501012)

值組也可視為由以欄為鍵值的字典，
令 t1 表示第 1 筆值組，
則 t1(id) 則會查出數值 1，
t1(name) 則會查出字串值「陳水扁」。

因為演算是關聯資料庫的查詢語言，
我們首先必須定義關聯資料庫。
基本的關係建造板塊是域或數據類型。
關係變數(relvar)是域和名字的有序對的集合，
它充當關係的表頭。關係是值組的集合。
儘管這些關係概念是數學定義，
這些定義可以寬鬆的映射到傳統的資料庫概念。
表是關係的可接受的可視表示；
值組類似於「行」的概念。

我們首先假定列名集合 c 的存在，
比如它們是 "name", "author", "address" 等等。
我們定義「表頭」為 c 的子集。
定義「關聯資料庫模式」為三值組 s = (d, r, h)，
這裡的 d 是原子值的域(更詳細的域和原子值的概念參見關聯式模型)，
r 是關係名字的有限集合，而

h : r → 2c

是向 r 中的每個關係名字關聯上表頭的函數。
(注意這是對完全關聯式模型的簡化，
那裡有多於一個域並且表頭不只是列名的集合還要映射這些列名到一個域。)
給定一個域 d 我們定義在 d 上的「值組」為偏函數
t : c → d
它映射某些列名到 d 中的原子值。一個例子是 (name : "harry", age : 25)。
在 d 上的所有值組的集合指示為 td。值組 t 定義於的 c 的子集稱為 t 的「域」(不要混淆於模式中的域)並指示為 dom(t)。
給定模式 s = (d, r, h) 最後我們定義「關聯資料庫」為函數
db : r → 2td
它映射 r 中的關係名字到 td 的有限子集，使得對於所有 r 中的關係名字和db(r) 中的值組 t 有著
dom(t) = h(r).
後者要求簡單的聲稱在關係中所有值組都應該包含同樣的列名，也就是在模式中所定義的那些。

項
~~
對於公式構造，我們假定值組變數的一個無限集合 v。
定義公式要給定一個資料庫模式 s = (d, r, h) 和一個偏函數 type : v -> 2c，
它定義指派表頭到某些值組變數的「類型指派」。
接著用如下規則定義「原子公式集合」 a[s,type]:
若 v 和 w 在 v 中，a 在 type(v) 中而 b 在 type(w) 中，則公式「v.a = w.b」在 a[s,type] 中，
若 v 在 v 中，a 在 type(v) 中而 k 指示 d 中一個值，則公式「v.a = k」在 a[s,type] 中，
若 v 在 v 中，r 在 r 中而 type(v) = h(r)，則公式「r(v)」在 a[s,type] 中。
原子的例子:
(t.age = s.age) — t 有一個 age 屬性而 s 有一個 age 屬性並有相同的值
(t.name = "codd") — 值組 t 有一個 name 屬性並且它的值是 "codd"
book(t) — 值組 t 存在於關係 book 中。
定義這種原子的形式語義要給定在 s 上的一個資料庫 db 和一筆值組變數綁定 val : v -> td，它映射值組變數到在 s 中的域上的值組:
「v.a = w.b」是真，若且唯若 val(v)(a) = val(w)(b)
「v.a = k」是真，若且唯若 val(v)(a) = k
「r(v)」是真，若且唯若 val(v) 在 db(r) 中

公式
~~~~
同一階邏輯一樣，
原子可用通過邏輯算子∧(與)、∨(或)和¬(非)組合成公式，而且我們可以使用存在量詞(∃) 和全稱量詞(∀)來綁定變數。通過如下規則歸納定義「公式集合」 f[s,type]:
所有在 a[s,type] 中原子也在 f[s,type] 中
若 f1 和 f2 在 f[s,type] 中，則公式「f1 ∧ f2」也在 f[s,type] 中
若 f1 和 f2 在 f[s,type] 中，則公式「f1 ∨ f2」也在 f[s,type] 中
若 f 在 f[s,type] 中，則公式「¬ f」也在 f[s,type] 中
若 v 在 v 中，h 是一個表頭而 f 是在 f[s,type[v->h]] 中的一個公式，則公式「∃ v : h ( f )」也在 f[s,type] 中，這裡的 type[v->h] 只是除了映射 v 到 h 之外同於 type 的函數。
若 v 在 v 中，h 是一個表頭而 f 是在 f[s,type[v->h]] 中的一個公式，則公式「∀ v : h ( f )」也在 f[s,type] 中
公式的例子:
t.name = "c. j. date" ∨ t.name = "h. darwen"
book(t) ∨ magazine(t)
∀ t : {author, title, subject} ( ¬ ( book(t) ∧ t.author = "c. j. date" ∧ ¬ ( t.subject = "relational model")))
注意最後的公式聲稱 c. j. date 所寫的所有書籍都有關聯式模型的主題。若不導致歧義，我們通常省略圓括號。
我們將假定在量詞量化於在模式中的域上所有值組的全集之上。給定在 s 上的資料庫 db 和值組變數綁定 val : v -> td，給出如下公式的形式語義:
「f1 ∧ f2」為真，若且唯若「f1」為真並且「f2」為真，
「f1 ∨ f2」為真，若且唯若「f1」為真或者「f2」為真，或者二者都為真，
「¬ f」為真，若且唯若「f」不為真，
「∃ v : h ( f )」為真，若且唯若存在一個 d 上的值組 t 使得 dom(t) = h 並且公式「f」對於 val[v->t] 為真，
「∀ v : h ( f )」為真，若且唯若對於所有 d 上的值組 t 使得 dom(t) = h 並且公式「f」對於 val[v->t] 為真。

查詢
~~~~
最後給定一個模式 s = (d, r, h) 我們定義查詢表達式為:
{ v : h | f(v) }
這裡的 v 是值組變數，h 是一個表頭而 f(v) 是 f[s,type] 中的公式，
其中 type = { (v, h) } 並帶有 v 做它的唯一自由變數。
對 s 上給定資料庫 db 的這種查詢的結果是在 d 上帶有 dom(t) = h 的使得 f 對於 db 為真並且 val = { (v, t) } 的所有值組 t的集合。

查詢表達式的例子:
{ t : {name} | ∃ s : {name, wage} ( employee(s) ∧ s.wage = 50.000 ∧ t.name = s.name ) }
{ t : {supplier, article} | ∃ s : {s#, sname} ( supplier(s) ∧ s.sname = t.supplier ∧ ∃ p : {p#, pname} ( product(p) ∧ p.pname = t.article ∧ ∃ a : {s#, p#} ( supplies(a) ∧ s.s# = a.s# ∧ a.p# = p.p# ) }

演算的語義和語法限制

域獨立查詢
~~~~~~~~~~
由於量詞的語義使得它們量化在模式中域上所有值組上，若假定了另一個模式則對一個特定資料庫的一個查詢可能傳回不同結果。例如考慮兩個模式 s1 = ( d1, r, h ) 和 s2 = ( d2, r, h )，帶有域 d1 = { 1 }, d2 = { 1, 2 }，關係名字 r = { "r1" } 和表頭 h = { ("r1", {"a"}) }。兩個模式有一個公共實例:
db = { ( "r1", { ("a", 1) } ) }
若我們考慮如下查詢表達式
{ t : {a} | t.a = t.a }
在它在 db 上的結果要麼是在 s1 下的 { (a : 1) } 
要麼是在 s2 下的 { (a : 1), (a : 2) }。
若我們採用域為無限集合，則查詢的結果也會是無限的，這是很明顯的。
要解決這些問題我們將把我們的注意力限制於「域獨立」的那些查詢，
就是說，對一個資料庫的查詢在它的所有模式下都傳回同樣的結果。
這些查詢的一個有價值的性質是若我們假定值組變數取值於所謂的這個資料庫「活躍域」上的值組，
它是在資料庫或在查詢表達式中的至少一筆值組中出現的域的子集，
則查詢表達式的語言不變。
事實上，在很多值組演算的定義中，量詞語義就是這麼定義的，
這使得定義的所有查詢都是域獨立的。

安全查詢
~~~~~~~~
為了限制查詢表達式使得它們只表示域獨立的查詢，
通常引入一個語法概念「安全查詢」。
要確定一個查詢是否為安全的，我們要從查詢導出兩種類型的信息。
首先是變數-列對 t.a 是否綁定到一個關係或一個常數的列上，
其次是兩個變數-列對是否直接或間接的相等(指示為 t.v == s.w)。
為了推導綁定性，我們引入如下推理規則:
在「v.a = w.b」中沒有變數-列對被綁定
在「v.a = k」中變數-列對 v.a 被綁定
在「r(v)」中所有的對 v.a 被綁定於 type(v) 中的 a，
在「f1 ∧ f2」 中所有的點對都被綁定於要麼 f1 中要麼 f2 中，
在「f1 ∨ f2」中所有的點對都被綁定於 f1 和 f2 二者中，
在「¬ f」中沒有點對被綁定，
在「∃ v : h ( f )」中對 w.a 被綁定，若它被綁定在 f 中並且 w <> v，
在「∀ v : h ( f )」中對 w.a 被綁定，若它在 f 中被綁定並且 w <> v。
為了推導相等性，
我們引入下列推理規則(位於常用的等價性推理規則: 自反性、對稱性和傳遞性之後):
在「v.a = w.b」中 v.a == w.b 成立，
在「v.a = k」中沒有點對相等，
在「r(v)」中沒有點對相等，
在「f1 ∧ f2」中 v.a == w.b 成立，若它要麼在 f1 中要麼在 f2 中成立，
在公式「f1 ∨ f2」中 v.a == w.b 成立，若它在 f1 和在 f2 二者中都成立，
「¬ f」沒有點對相等，
在「∃ v : h ( f )」中 w.a == x.b 成立，若它在 f 中成立並且 w<>v 並且 x<>v，
在「∀ v : h ( f )」中 w.a == x.b 成立，若它在 f 中成立並且 w<>v 並且 x<>v。
我們接著聲稱一個查詢表達式 { v : h | f(v) } 是安全的，若
對於所有 h 中的列名 a，我們可以得出 v.a 等於一個 f 中的綁定對，
對於形如「∀ w : g ( g )」的所有 f 的子表達式，
我們可以得出對於所有 g 中的列名 a 我們可以得出 w.a 等於一個 g 中的綁定對，
對於形如「∃ w : g ( g )」的所有 f 的子表達式，
我們可以得出對於所有 g 中的列名 a 我們可以得出 w.a 等於一個 g 中綁定對。
安全查詢表達式的限制不限制表達能力，
因為所有能被表達出來的域獨立查詢都可以用安全查詢表達式表達。
這可以做如下證明，對於模式 s = (d, r, h)，
給定在這個查詢表示式中常數的集合 k，
值組變數 v 和表頭 h，我們可以為所有的對 v.a 構造一個安全公式，
它帶有 a 在 h 中並聲稱其值在活躍域中。
例如，假定 k={1,2}、r={"r"} 和 h = { ("r", {"a, "b"}) } 
則 v.b 對應的安全公式為:
v.b = 1 ∨ v.b = 2 ∨ ∃ w ( r(w) ∧ ( v.b = w.a ∨ v.b = w.b ) )
接著通過在這個表達式中用到地方對所有變數 v 和它的類型中的列名 a 增加這個公式，
可以用這個公式來把任何不安全的查詢表達式重寫為等價的安全查詢表達式。這有效的使得所有變數都取值於活躍域之上，若表達的查詢是域獨立的，象已經解說的那樣不改變語義。
