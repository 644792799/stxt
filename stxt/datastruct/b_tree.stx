B-樹
====
B-樹是符合下面限制的樹：
* 每個節點最多有 m 個子樹
* 除了根及葉，每個節點至少有 m/2 個子樹
* 根若不是葉，至少有 2 個子樹
* 非葉節點，至少有 2 個子樹

令 x 為 B-樹的節點，且節點存放 n(x) 的鍵值，
令 ki 表示第 i 位置的鍵值，
則鍵值應滿足：

B-樹每個節點會存放一指標，用來指出此節點的型態，
節點有兩種型態：葉和內部節點，
沒有父節點的節點稱為根。
</listitem>
<listitem>若 x 為內部節點，則有 n(x)+1 的指標指向不同子樹，
每個子樹也是 B-樹，
令 k<subscript>c(i)</subscript>為第 i 個指標指向的子樹 c(i) 的任意節點，
則滿足
每個 B-樹都有一個最小因子，用來控制子樹的數目，
令最小因子為 m 則，除根葉外的節點 x，
其子樹數目 n(x)+1 滿足式：

，同理可推得鍵值數目必須滿足式：
，而葉其子樹數目為 0，但其鍵值數目同內部節點。
葉等高
B-樹定理
<para>
令 h 為 B-樹的高度，n 為其鍵值數目，m 為最小因子，則
證明：
</equation>
</para>
</sect2>
6.5.1	B*-樹	B*-Tree	
	*B*T除根葉外，子樹數目 d 滿足下式：	
	ceil(M*2/3)&lt;=d&lt;=M	
6.5.2	B+-樹	B+-Tree	
	所有的資料都存在葉子的 BT。
	這樣的話，索引及資料都可以存在同一個結構。而 B*-樹節點
	存的只是指標。
	在 Oracle 中，B+T用來制作 Clustered Index
6.5.3	應用為 DBMS 的 INDEX	
	*BT 可作為大量資料的 index 的實作	
	像是 Oracle DBMS 便是使用 B*T 作為 Index 的結構。

	DBMS 使用 INDEX 的目的如下：
	*加快搜尋速度	

	*實作 UNIQUE CONSTRAINT	
	由於 DBMS 常需要某欄位的值不含有重覆值，像是 RDBMS 中
	table 的主鍵，故要能快速判斷新插入的值是否重覆，便要使
	為主鍵建立 INDEX。	
