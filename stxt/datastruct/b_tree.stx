B-樹
====
m-路搜尋樹
----------
m-路搜尋樹(m-way search tree)可能是空的，或者滿足下列的特性：
# 每個節點最多有 m 個子樹
# 若一節點 N 具有 n 個鍵值，其結構如下所示：

  N:(C0), (K1, C1), (K2, C2),...,(Kn, Cn)

　其中 Ci , 0 <= i <= n < m 為指向子樹的指標，而 
       Ki , 1 <= i <= n < m 為鍵值。

# 每個鍵值依序排列，滿足下式：

  Ki < Ki+1 , 1 <= i  < m。
  
# 所有在子樹 Ci 中的鍵值小於 K(i+1) ，大於 Ki, 0 < i < n。
# 所有在子樹 Cn 中的鍵值大於 Kn ，所有在子樹 C0 中的鍵值小於 K1 。
# 所有的子樹 Ci , 0 <= i <= n 也是 m-路搜尋樹。

m 稱為最小因子，用來控制子樹的數目。

B-樹限制
--------
每個 B-樹具有一個度數(order)，若度數為 t，則記為 B(t)-樹
必須滿足以下限制：
# 其為一個 2t-路搜尋樹
# 根若不是葉，至少有 2 個子樹
# 除了根及葉，每個節點至少有 t 個子樹
# 葉其子樹數目為 0，但其鍵值數目同內部節點
# 所有葉高度相同

限制用至少子樹數 t 定義，而不用最多子樹數 m 來定義，
因為使用 m 定義最少子樹數如下式：

ceil(m/2) 

必須用到 ceil 函數，而使用 t 定義最多子樹數如下式：

2t

較為簡單

B-樹定理
--------
令 h 為 B(t)-樹的高度，n 為其鍵值數目，則滿足式：

log(n+1/2, 2t) <= h <= log(n+1/2, t)

證明：
  h 的上限證明
  # n >= 1 + 2(t-1) + 2(t-1)t +...+ 2(t-1)t**h
  # n >= 1 + 2(t-1)(1 + t + t**2 +...+  t**h)
  # n >= 1 + 2(t-1)( 1   -t**h / 1-t)
  # n >= 1 + 2(t-1)( t**h-1     / t-1)
  # n >= 1 + 2(t**h-1)
  # n >= 2(t**h)-1
  # n+1 / 2 >= t**h
  # log(n+1/2, t) >= h
  # h <= log(n+1/2, t)

  h 的下限證明
  # n   =< (2t-1) + (2t-1)2t + (2t-1)2t**2 +...+ 2(t-1)2t**h
  # n   =< (2t-1)(1 + 2t + 2t**2 +...+  2t**h)
  # n   =< (2t-1)(1    - 2t**h / 1 -2t)
  # n   =< (2t-1)(2t**h- 1     / 2t-1 )
  # n   =< 2t**h- 1
  # n+1 =< 2t**h
  # log(n+1, 2t) =< h

B*-樹
=====
B*-樹除根葉外，子樹數目 c 滿足下式：	

ceil(m*2/3) =< c =< m	

其中 m 為最大子樹數。

B+樹
====
B(m)+樹具有下列特性：
# 
# 所有的資料都存在葉的 B(m)-樹

code.搜尋B+樹
def search(record r)
  u = root
  while not leaf(u)
    for i, k in enum(u.keys)
      if
    u = node
    scan u for r
::

B+樹的索引及資料都可以存在同一個結構，
因為 B+樹節點存的只是指標。
在 Oracle 中，B+樹用來制作 Clustered Index

應用為 DBMS 的 INDEX	
====================
	*BT 可作為大量資料的 index 的實作	
	像是 Oracle DBMS 便是使用 B*T 作為 Index 的結構。

	DBMS 使用 INDEX 的目的如下：
	*加快搜尋速度	

	*實作 UNIQUE CONSTRAINT	
	由於 DBMS 常需要某欄位的值不含有重覆值，像是 RDBMS 中
	table 的主鍵，故要能快速判斷新插入的值是否重覆，便要使
	為主鍵建立 INDEX。	
  B樹索引是數據庫中存取和查找文件(稱為記錄或鍵值)的一
  種方法。B-tree算法減少定位記錄時所經歷的中間過程，從而加快存取速度。
