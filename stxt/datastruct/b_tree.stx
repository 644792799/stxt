B 樹
====
M 路搜尋樹
----------
M 路搜尋樹(m-way search tree)可能是空的，或者滿足下列的特性：

# 每個節點最多有 m 個子樹
# 若一節點 N 具有 n 個鍵值，其結構如下所示：
  N:(C0), (K1, C1), (K2, C2),...,(Kn, Cn)

  其中 Ci , 0 <= i <= n < m 為指向子樹的指標，而 
       Ki , 1 <= i <= n < m 為鍵值。

# 每個鍵值依序排列，滿足下式：
  Ki < Ki+1 , 1 <= i  < m。

# 所有在子樹 Ci 中的鍵值小於 K(i+1) ，大於 Ki, 0 < i < n。
# 所有在子樹 Cn 中的鍵值大於 Kn ，所有在子樹 C0 中的鍵值小於 K1 。
# 所有的子樹 Ci , 0 <= i <= n 也是 M 路搜尋樹。

m 稱為最小因子，用來控制子樹的數目。

B 樹限制
--------
每個 B 樹具有一個度數(order)，若度數為 m，則記為 B(m)樹
必須滿足以下限制：

# 其為一個 M 路搜尋樹
# 除了根及葉，每個節點至少有 [m/2][#]_ 個子樹
# 根若不是葉，至少有 2 個子樹

若限制用使用至少子樹數 t 定義，而不用最多子樹數 m 來定義，
因為使用 m 定義最少子樹數如下式：

[m/2] 

必須用到 ceil 函數，而使用 t 定義最多子樹數如下式：

2t

較為簡單

.. [#] [n] = ceil(n)

B 樹定理
--------
令 h 為 B(M)-樹的高度，n 為其鍵值數目，則滿足式：

log(n, M) <= h <= log(n, [M/2])

證明
~~~~
h 的上限證明

# m := [M/2]
# n >= 1 + 2(m-1) + 2(m-1)m +...+ 2(m-1)m**h
# n >= 1 + 2(m-1)(1 + m + m**2 +...+  m**h)
# n >= 1 + 2(m-1)( 1   -m**h / 1-m)
# n >= 1 + 2(m-1)( m**h-1     / m-1)
# n >= 1 + 2(m**h-1)
# n >= 2(m**h)-1
# n+1 / 2 >= m**h
# log(n+1/2, m) >= h
# h <= log(n+1/2, m)
# h <= log(n, [M/2])

h 的下限證明

# n   <=  M-1 + (M-1)M + (M-1)M**2 + ... + (M-1)M**h
# n   <= (M-1)(1 + M + M**2 + ... + M**h)
# n   <= (M-1)(1 - M**h / 1 - M)
# n   <= (M-1)(M**h - 1 / M - 1)
# n   <= M**h - 1
# n+1 <= M**h
# log(n+1, M) <= h
# log(n+1, M) <= h
# log(n, M)   <= h

B*樹
=====
B*樹除根葉外，子樹數目 c 滿足下式：	

ceil(m*2/3) <= c <= m	

其中 m 為最大子樹數。

B+樹
====
B(m)+樹具有下列特性：

# 所有的資料都存在葉的 B(m)-樹

code.搜尋B+樹
def search(record r)
  u = root
  while not leaf(u)
    for i, k in enum(u.keys)
      if
    u = node
    scan u for r
::

B+樹的索引及資料都可以存在同一個結構，
因為 B+樹節點存的只是指標。
在 Oracle 中，B+樹用來制作 Clustered Index

應用為 DBMS 的 INDEX	
--------------------
DBMS 使用 INDEX 的目的如下：

BT 可作為大量資料的 index 的實作
B樹索引是數據庫中存取和查找文件(稱為記錄或鍵值)的一種方法。
能減少定位記錄時所經歷的中間過程，從而加快存取速度。

加快搜尋速度

實作 UNIQUE CONSTRAINT	
由於 DBMS 常需要某欄位的值不含有重覆值，像是 RDBMS 中
表格的主鍵，故要能快速判斷新插入的值是否重覆，便要為主鍵建立
INDEX。
