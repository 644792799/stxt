#!/usr/bin/python -u
#
# listen on UDP port, write syslog to one file per host
#
# Features:
# - builtin DNS cache
# - SIGHUP causes close/open of logfiles (e.g. for logrotate)
#
# andras.horvath@gmail.com, 2007
#
# TODO: limit number of clients (honor 'maxclients')
# TODO: some more sophisticated argument parsing
# TODO: options about FQDN/hostname
# TODO: write manual page

import os,socket,signal,sys,time,syslog,getopt,pwd;

# clean exit on SIGINT aka ^C (sigterm works by default)
# the interpreter closes the files for us :P
def endprocess(signum,frame):
	mymessage(0,"exiting on SIGINT.")
	sys.exit(0)

# close/open logfiles on SIGHUP
# (e.g. to be used by logrotate; move file, call this, and use the moved file)
def closeopen(signum,frame):
	mymessage(2,"SIGHUP, closeopen() called")
	# for c in x.keys(), because otherwise 'del' will throw an exception
	# welcome to python :-P
	for c in open_channels.keys():
		open_channels[c].reopenfile()
		if open_channels[c].cleanup==1:
			# remove idle log channel
			# the garbage collector should destroy the object, right? :-P FIXME
			mymessage(1,"Deleting idle log channel %s" % c)
			del open_channels[c]
	mymessage(2,"closeopen() finished")

# log to syslog, depending on debug level
def mymessage(d,m):
	if debug>=d:
		syslog.syslog("(%d) %s" % (d,m))
	# this means we're running in foreground
	if debug>0:
		print "(%d) %s" % (d,m)

# one log channel is a log file for a given host
# (create one when a new host is "seen")
# plus the associated DNS cache, timers and whatnot
class logchannel:
	################################################################
	def __init__(self,logdir,ipaddr):
		self.ip=ipaddr
		self.logdir=logdir
		self.dnscachetimeout=dnscachemax
		# current time (unix time), will be overwritten by resolveip
		self.now=0
		# last time we've updated hostname from IP address (unix time)
		# zero forces an update now
		self.lastdnsupdate=0
		self.oldhostname=''
		# to be overwritten by resolveip() if it succeeds
		self.hostname=ipaddr
		self.resolveip()
		# last time we've written to this file: never
		self.lastwrite=0
		# (re)open log file
		self.reopenfile()
		# is this log channel subject to garbage collection? not just yet :)
		self.cleanup=0
	################################################################
	# (re)resolve an IP address, if dnscachetimeout has passed
	def resolveip(self):
		mymessage(2, "resolveip called %s" % self.ip )
		self.now=time.time()
		# if DNS cache is stale, re-resolve IP
		if self.lastdnsupdate+self.dnscachetimeout < self.now:
			mymessage(2,"re-resolve ip %s" % self.ip )
			self.dnscachetimeout=dnscachemax
			self.lastdnsupdate=self.now
			self.oldhostname=self.hostname
			try:
				self.hostname=socket.gethostbyaddr(self.ip)[0]
				# strip FQDN (syslog doesn't log them either)
				self.hostname=self.hostname.split('.')[0]
			except:
				mymessage(0,"DNS resolution error: (%s) %s" % ( sys.exc_info()[1][0], sys.exc_info()[1][1] ))
				# fall back to previous (good or bad) resolution
				self.hostname=self.oldhostname
				self.oldhostname=self.ip
				# DNS lookup failed and that's not good, so we'll retry sooner than normal
				self.dnscachetimeout=dnscachequick
			mymessage(1, "re-resolve ip: hostname was %s, now %s" % (self.oldhostname, self.hostname))
	################################################################
	# (close and )(re)open logfile
	def reopenfile(self):
		mymessage(1,"closing file %s" % os.path.join(self.logdir,self.hostname))
		# close any old file if it exists
		if (self.oldhostname != ''):
			try:
				self.file.close()
			except:
				mymessage(1,"File not open for %s (was %s, ip %s)" % (self.hostname,self.oldhostname,self.ip))
		self.now=time.time()
		# open file IF this is the first time we write to it,
		# OR if it hasn't spent too much time open without getting written to
		if (self.lastwrite == 0) or (self.now-self.lastwrite < keeptime):
			mymessage(2,"reopening file %s" % os.path.join(self.logdir,self.hostname))
			try:
				# open file unbuffered 
				self.file=open(os.path.join(self.logdir,self.hostname),'a',0)
			except:
				mymessage(0,"Error opening %s: (%s) %s" % ( os.path.join(self.logdir,self.hostname), sys.exc_info()[1][0], sys.exc_info()[1][1] ))
		else:
			mymessage(1,"NOT reopening file %s" % os.path.join(self.logdir,self.hostname))
			# mark ourselves as cleanup-able
			self.cleanup=1
	################################################################
	# call this to write data to this logfile. Date will be appended.
	def write(self,data):
		mymessage(2,"write() called for %s (ip=%s)" % (self.hostname, self.ip))
		self.resolveip()
		if self.oldhostname != self.hostname:
			self.reopenfile()
			self.oldhostname = self.hostname
		# syslog's idiotic time format. Note that 'year' is not included :(
		self.formattedtime=time.strftime('%b %d %H:%M:%S',time.localtime())
		try:
			# add date
			self.file.write(self.formattedtime+" "+self.hostname+" ")
			# strip leading "<thingy>" (that's the log level and we aren't interested) 
			# and write log data to the file
			self.file.write(data.lstrip('<0123456789>'))
			# add newline if necessary...
			# regular syslog comes with a newline terminator (RHEL4 clients)
			# rsyslog does not (RHEL5 clients)
			if ( data[-1] != "\n" ):
				self.file.write("\n")
			# just to be doubly sure everything went to at least the kernel buffers
			self.file.flush()
			self.lastwrite=time.time()
		except:
			mymessage(0,"Error writing to %s: (%s) %s" % ( os.path.join(self.logdir,self.hostname), sys.exc_info()[1][0], sys.exc_info()[1][1] ))

############# Main Program #############

syslog.openlog("rxlogd")

signalhandler=signal.signal(signal.SIGINT,endprocess)
signalhandler=signal.signal(signal.SIGHUP,closeopen)

# defaults
logdir='/var/log/remote'
bufsiz=1500
port=514
user='nobody'
# how often to re-resolve IP addresses in normal cases, in seconds
# default is 10 minutes
dnscachemax=600
# how often to retry on errors, in seconds
# default is 3 minutes
dnscachequick=180
# default debug level
debug=0
# maximum number of 'live' clients (with files open)
maxclients=1000 # FIXME not used
# this many seconds of inactivity until we close the file at the next reopenfile()
keeptime=90

# option parsing

def usage():
	print "Remote Syslog Receiver and Logger daemon"
	print "rxlogd -l <logdirectory> [ -p <port> ] [ -d ] [ -h ]"
	print " -l <dir>  | --logdir=<logdirectory> : where to put the logfiles"
	print " -p <port> | --port=<port>           : local UDP port to bind to"
	print " -u <user> | --user=<username>       : user to run as (default nobody)"
	#print " -m <num>  | --maxclients=<number>   : maximum number of clients at any time (default 1000)"
	print " -d <level>| --debug <level>         : debug (default level 0 == errors only, 2=verbose)"
	print " -h        | --help                  : this text"
	sys.exit(0)
try:
	opts, args = getopt.getopt(sys.argv[1:], "l:p:u:d:h", ["logdir=", "port=", "user=", "debug"])
except getopt.GetoptError:
	#print help information and exit:
	usage()
	sys.exit(2)

for o, a in opts:
	if o in ("-h","--help"):
		usage()
	if o in ("-d","--debug"):
		try:
			debug=int(a)
		except:
			mymessage(0,"Error: debug level is an integer >=0 (0=nothing, 2=verbose)")
			sys.exit(1)
	if o in ("-p","--port"):
		try:
			port=int(a)
		except:
			mymessage(0,"Error: port must be >0")
			sys.exit(1)
	if o in ("-l","--logdir"):
		logdir=a
	if o in ("-u","--user"):
		user=a
	if o in ("-m","--maxclients"):
		try:
			maxclients=int(a) # FIXME exceptions
		except:
			mymessage(0,"Error: maxclients must be >0")
			sys.exit(1)
		if maxclients<=0:
			mymessage(0,"Error: maxclients must be >0")
			sys.exit(1)

# open listening socket

try:
	sock=socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
	sock.bind(("0.0.0.0",port))
except:
	mymessage(0,"Socket error: (%s) %s" % ( sys.exc_info()[1][0], sys.exc_info()[1][1] ))
	sys.exit(1)

# drop privileges
try:
	u=pwd.getpwnam(user)
	os.setegid(u.pw_uid)
	os.seteuid(u.pw_uid)
	mymessage(1,"running as %s:%s" % ( os.geteuid(), os.getegid() ))
except:
	mymessage(0,"Failed to become user : %s (%s:%s) %s" % (user,u.pw_uid,u.pw_gid,sys.exc_info()[1]))
	sys.exit(1)

# fork into background
if debug==0:
	pid=os.fork()
	if pid!=0:
		sys.exit()

# create log directory if it doesn't exist
# we don't try too hard - the log writer code will die on error
try:
	if not os.path.isdir(logdir):
		os.makedirs(logdir)
except:
	mymessage(0,"Log directory error: %s " % ( sys.exc_info()[1] ))
	sys.exit(1)

# list of channels we have open, ip address to object mapping
open_channels={}
while 1:
	# recvfrom can only fail e.g. if interrupted by a signal
	# in which case we retry :)
	# all other exceptions are taken care of elsewhere
	try:
		data,addr=sock.recvfrom(bufsiz)
		if addr[0] not in open_channels:
			# there's a new client right here, so we add it to the list...
			open_channels[addr[0]]=logchannel(logdir,addr[0])
		# write input to file. it's that simple :)
		open_channels[addr[0]].write(data)
	except socket.error:
		pass

# vim: ai
